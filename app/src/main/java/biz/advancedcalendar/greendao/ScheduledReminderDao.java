package biz.advancedcalendar.greendao;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.Property;
import de.greenrobot.dao.internal.DaoConfig;
import de.greenrobot.dao.internal.SqlUtils;
import de.greenrobot.dao.query.Query;
import de.greenrobot.dao.query.QueryBuilder;
import java.util.ArrayList;
import java.util.List;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
/** DAO for table SCHEDULED_REMINDER. */
public class ScheduledReminderDao extends AbstractDao<ScheduledReminder, Long> {
	public static final String TABLENAME = "SCHEDULED_REMINDER";

	/** Properties of entity ScheduledReminder.<br/>
	 * Can be used for QueryBuilder and for referencing column names. */
	public static class Properties {
		public final static Property Id = new Property(0, Long.class, "id", true, "_id");
		public final static Property ReminderId = new Property(1, Long.class,
				"reminderId", false, "REMINDER_ID");
		public final static Property ElapsedReminderId = new Property(2, Long.class,
				"elapsedReminderId", false, "ELAPSED_REMINDER_ID");
		public final static Property IsQuickReminder = new Property(3, boolean.class,
				"isQuickReminder", false, "IS_QUICK_REMINDER");
		public final static Property AssignedRemindAtDateTime = new Property(4,
				long.class, "assignedRemindAtDateTime", false,
				"ASSIGNED_REMIND_AT_DATE_TIME");
		public final static Property NextSnoozeDateTime = new Property(5, long.class,
				"nextSnoozeDateTime", false, "NEXT_SNOOZE_DATE_TIME");
		public final static Property ActualLastAlarmedDateTime = new Property(6,
				Long.class, "actualLastAlarmedDateTime", false,
				"ACTUAL_LAST_ALARMED_DATE_TIME");
		public final static Property SnoozeCount = new Property(7, int.class,
				"snoozeCount", false, "SNOOZE_COUNT");
		public final static Property StateValue = new Property(8, int.class,
				"stateValue", false, "STATE");
		public final static Property Text = new Property(9, String.class, "text", false,
				"TEXT");
		public final static Property IsAlarm = new Property(10, boolean.class, "isAlarm",
				false, "IS_ALARM");
		public final static Property Enabled = new Property(11, boolean.class, "enabled",
				false, "ENABLED");
		public final static Property Ringtone = new Property(12, String.class,
				"ringtone", false, "RINGTONE");
		public final static Property RingtoneFadeInTime = new Property(21, Long.class,
				"ringtoneFadeInTime", false, "RINGTONE_FADE_IN_TIME");
		public final static Property PlayingTime = new Property(13, Integer.class,
				"playingTime", false, "PLAYING_TIME");
		public final static Property AutomaticSnoozeDuration = new Property(14,
				Integer.class, "automaticSnoozeDuration", false,
				"AUTOMATIC_SNOOZE_DURATION");
		public final static Property AutomaticSnoozesMaxCount = new Property(15,
				Integer.class, "automaticSnoozesMaxCount", false,
				"AUTOMATIC_SNOOZES_MAX_COUNT");
		public final static Property Vibrate = new Property(16, Boolean.class, "vibrate",
				false, "VIBRATE");
		public final static Property VibratePattern = new Property(17, String.class,
				"vibratePattern", false, "VIBRATE_PATTERN");
		public final static Property Led = new Property(18, Boolean.class, "led", false,
				"LED");
		public final static Property LedPattern = new Property(19, String.class,
				"ledPattern", false, "LED_PATTERN");
		public final static Property LedColor = new Property(20, Integer.class,
				"ledColor", false, "LED_COLOR");
	};

	private DaoSession daoSession;
	private Query<ScheduledReminder> reminder_ScheduledReminderListQuery;

	public ScheduledReminderDao(DaoConfig config) {
		super(config);
	}

	public ScheduledReminderDao(DaoConfig config, DaoSession daoSession) {
		super(config, daoSession);
		this.daoSession = daoSession;
	}

	/** Creates the underlying database table. */
	public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
		String constraint = ifNotExists ? "IF NOT EXISTS " : "";
		db.execSQL("CREATE TABLE " + constraint + "'SCHEDULED_REMINDER' (" + //
				"'_id' INTEGER PRIMARY KEY ," + // 0: id
				"'REMINDER_ID' INTEGER," + // 1: reminderId
				"'ELAPSED_REMINDER_ID' INTEGER," + // 2: elapsedReminderId
				"'IS_QUICK_REMINDER' INTEGER NOT NULL ," + // 3: isQuickReminder
				"'ASSIGNED_REMIND_AT_DATE_TIME' INTEGER NOT NULL ," + // 4:
																		// assignedRemindAtDateTime
				"'NEXT_SNOOZE_DATE_TIME' INTEGER NOT NULL ," + // 5: nextSnoozeDateTime
				"'ACTUAL_LAST_ALARMED_DATE_TIME' INTEGER," + // 6:
																// actualLastAlarmedDateTime
				"'SNOOZE_COUNT' INTEGER NOT NULL ," + // 7: snoozeCount
				"'STATE' INTEGER NOT NULL ," + // 8: stateValue
				"'TEXT' TEXT NOT NULL ," + // 9: text
				"'IS_ALARM' INTEGER NOT NULL ," + // 10: isAlarm
				"'ENABLED' INTEGER NOT NULL ," + // 11: enabled
				"'RINGTONE' TEXT," + // 12: ringtone
				"'PLAYING_TIME' INTEGER," + // 13: playingTime
				"'AUTOMATIC_SNOOZE_DURATION' INTEGER," + // 14: automaticSnoozeDuration
				"'AUTOMATIC_SNOOZES_MAX_COUNT' INTEGER," + // 15: automaticSnoozesMaxCount
				"'VIBRATE' INTEGER," + // 16: vibrate
				"'VIBRATE_PATTERN' TEXT," + // 17: vibratePattern
				"'LED' INTEGER," + // 18: led
				"'LED_PATTERN' TEXT," + // 19: ledPattern
				"'LED_COLOR' INTEGER," + // 20: ledColor
				"'RINGTONE_FADE_IN_TIME' INTEGER);"); // 21: ringtoneFadeInTime
	}

	/** Drops the underlying database table. */
	public static void dropTable(SQLiteDatabase db, boolean ifExists) {
		String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "")
				+ "'SCHEDULED_REMINDER'";
		db.execSQL(sql);
	}

	/** @inheritdoc */
	@Override
	protected void bindValues(SQLiteStatement stmt, ScheduledReminder entity) {
		stmt.clearBindings();
		Long id = entity.getId();
		if (id != null) {
			stmt.bindLong(1, id);
		}
		Long reminderId = entity.getReminderId();
		if (reminderId != null) {
			stmt.bindLong(2, reminderId);
		}
		Long elapsedReminderId = entity.getElapsedReminderId();
		if (elapsedReminderId != null) {
			stmt.bindLong(3, elapsedReminderId);
		}
		stmt.bindLong(4, entity.getIsQuickReminder() ? 1l : 0l);
		stmt.bindLong(5, entity.getAssignedRemindAtDateTime());
		stmt.bindLong(6, entity.getNextSnoozeDateTime());
		Long actualLastAlarmedDateTime = entity.getActualLastAlarmedDateTime();
		if (actualLastAlarmedDateTime != null) {
			stmt.bindLong(7, actualLastAlarmedDateTime);
		}
		stmt.bindLong(8, entity.getSnoozeCount());
		stmt.bindLong(9, entity.getStateValue());
		stmt.bindString(10, entity.getText());
		stmt.bindLong(11, entity.getIsAlarm() ? 1l : 0l);
		stmt.bindLong(12, entity.getEnabled() ? 1l : 0l);
		String ringtone = entity.getRingtone();
		if (ringtone != null) {
			stmt.bindString(13, ringtone);
		}
		Long ringtoneFadeInTime = entity.getRingtoneFadeInTime();
		if (ringtoneFadeInTime != null) {
			stmt.bindLong(22, ringtoneFadeInTime);
		}
		Integer playingTime = entity.getPlayingTime();
		if (playingTime != null) {
			stmt.bindLong(14, playingTime);
		}
		Integer automaticSnoozeDuration = entity.getAutomaticSnoozeDuration();
		if (automaticSnoozeDuration != null) {
			stmt.bindLong(15, automaticSnoozeDuration);
		}
		Integer automaticSnoozesMaxCount = entity.getAutomaticSnoozesMaxCount();
		if (automaticSnoozesMaxCount != null) {
			stmt.bindLong(16, automaticSnoozesMaxCount);
		}
		Boolean vibrate = entity.getVibrate();
		if (vibrate != null) {
			stmt.bindLong(17, vibrate ? 1l : 0l);
		}
		String vibratePattern = entity.getVibratePattern();
		if (vibratePattern != null) {
			stmt.bindString(18, vibratePattern);
		}
		Boolean led = entity.getLed();
		if (led != null) {
			stmt.bindLong(19, led ? 1l : 0l);
		}
		String ledPattern = entity.getLedPattern();
		if (ledPattern != null) {
			stmt.bindString(20, ledPattern);
		}
		Integer ledColor = entity.getLedColor();
		if (ledColor != null) {
			stmt.bindLong(21, ledColor);
		}
	}

	@Override
	protected void attachEntity(ScheduledReminder entity) {
		super.attachEntity(entity);
		entity.__setDaoSession(daoSession);
	}

	/** @inheritdoc */
	@Override
	public Long readKey(Cursor cursor, int offset) {
		return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
	}

	/** @inheritdoc */
	@Override
	public ScheduledReminder readEntity(Cursor cursor, int offset) {
		ScheduledReminder entity = new ScheduledReminder( //
				cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
				cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1), // reminderId
				cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2), // elapsedReminderId
				cursor.getShort(offset + 3) != 0, // isQuickReminder
				cursor.getLong(offset + 4), // assignedRemindAtDateTime
				cursor.getLong(offset + 5), // nextSnoozeDateTime
				cursor.isNull(offset + 6) ? null : cursor.getLong(offset + 6), // actualLastAlarmedDateTime
				cursor.getInt(offset + 7), // snoozeCount
				cursor.getInt(offset + 8), // stateValue
				cursor.getString(offset + 9), // text
				cursor.getShort(offset + 10) != 0, // isAlarm
				cursor.getShort(offset + 11) != 0, // enabled
				cursor.isNull(offset + 12) ? null : cursor.getString(offset + 12), // ringtone
				cursor.isNull(offset + 21) ? null : cursor.getLong(offset + 21), // playingTime
				cursor.isNull(offset + 13) ? null : cursor.getInt(offset + 13), // automaticSnoozeDuration
				cursor.isNull(offset + 14) ? null : cursor.getInt(offset + 14), // automaticSnoozesMaxCount
				cursor.isNull(offset + 15) ? null : cursor.getInt(offset + 15), // vibrate
				cursor.isNull(offset + 16) ? null : cursor.getShort(offset + 16) != 0, // vibratePattern
				cursor.isNull(offset + 17) ? null : cursor.getString(offset + 17), // led
				cursor.isNull(offset + 18) ? null : cursor.getShort(offset + 18) != 0, // ledPattern
				cursor.isNull(offset + 19) ? null : cursor.getString(offset + 19), // ledColor
				cursor.isNull(offset + 20) ? null : cursor.getInt(offset + 20)// ringtoneFadeInTime
		);
		return entity;
	}

	/** @inheritdoc */
	@Override
	public void readEntity(Cursor cursor, ScheduledReminder entity, int offset) {
		entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
		entity.setReminderId(cursor.isNull(offset + 1) ? null : cursor
				.getLong(offset + 1));
		entity.setElapsedReminderId(cursor.isNull(offset + 2) ? null : cursor
				.getLong(offset + 2));
		entity.setIsQuickReminder(cursor.getShort(offset + 3) != 0);
		entity.setAssignedRemindAtDateTime(cursor.getLong(offset + 4));
		entity.setNextSnoozeDateTime(cursor.getLong(offset + 5));
		entity.setActualLastAlarmedDateTime(cursor.isNull(offset + 6) ? null : cursor
				.getLong(offset + 6));
		entity.setSnoozeCount(cursor.getInt(offset + 7));
		entity.setStateValue(cursor.getInt(offset + 8));
		entity.setText(cursor.getString(offset + 9));
		entity.setIsAlarm(cursor.getShort(offset + 10) != 0);
		entity.setEnabled(cursor.getShort(offset + 11) != 0);
		entity.setRingtone(cursor.isNull(offset + 12) ? null : cursor
				.getString(offset + 12));
		entity.setPlayingTime(cursor.isNull(offset + 13) ? null : cursor
				.getInt(offset + 13));
		entity.setAutomaticSnoozeDuration(cursor.isNull(offset + 14) ? null : cursor
				.getInt(offset + 14));
		entity.setAutomaticSnoozesMaxCount(cursor.isNull(offset + 15) ? null : cursor
				.getInt(offset + 15));
		entity.setVibrate(cursor.isNull(offset + 16) ? null : cursor
				.getShort(offset + 16) != 0);
		entity.setVibratePattern(cursor.isNull(offset + 17) ? null : cursor
				.getString(offset + 17));
		entity.setLed(cursor.isNull(offset + 18) ? null
				: cursor.getShort(offset + 18) != 0);
		entity.setLedPattern(cursor.isNull(offset + 19) ? null : cursor
				.getString(offset + 19));
		entity.setLedColor(cursor.isNull(offset + 20) ? null : cursor.getInt(offset + 20));
		entity.setRingtoneFadeInTime(cursor.isNull(offset + 21) ? null : cursor
				.getLong(offset + 21));
	}

	/** @inheritdoc */
	@Override
	protected Long updateKeyAfterInsert(ScheduledReminder entity, long rowId) {
		entity.setId(rowId);
		return rowId;
	}

	/** @inheritdoc */
	@Override
	public Long getKey(ScheduledReminder entity) {
		if (entity != null) {
			return entity.getId();
		} else {
			return null;
		}
	}

	/** @inheritdoc */
	@Override
	protected boolean isEntityUpdateable() {
		return true;
	}

	/** Internal query to resolve the "scheduledReminderList" to-many relationship of
	 * Reminder. */
	public List<ScheduledReminder> _queryReminder_ScheduledReminderList(Long reminderId) {
		synchronized (this) {
			if (reminder_ScheduledReminderListQuery == null) {
				QueryBuilder<ScheduledReminder> queryBuilder = queryBuilder();
				queryBuilder.where(Properties.ReminderId.eq(null));
				reminder_ScheduledReminderListQuery = queryBuilder.build();
			}
		}
		Query<ScheduledReminder> query = reminder_ScheduledReminderListQuery
				.forCurrentThread();
		query.setParameter(0, reminderId);
		return query.list();
	}

	private String selectDeep;

	protected String getSelectDeep() {
		if (selectDeep == null) {
			StringBuilder builder = new StringBuilder("SELECT ");
			SqlUtils.appendColumns(builder, "T", getAllColumns());
			builder.append(',');
			SqlUtils.appendColumns(builder, "T0", daoSession.getReminderDao()
					.getAllColumns());
			builder.append(',');
			SqlUtils.appendColumns(builder, "T1", daoSession.getElapsedReminderDao()
					.getAllColumns());
			builder.append(" FROM SCHEDULED_REMINDER T");
			builder.append(" LEFT JOIN REMINDER T0 ON T.'REMINDER_ID'=T0.'_id'");
			builder.append(" LEFT JOIN ELAPSED_REMINDER T1 ON T.'ELAPSED_REMINDER_ID'=T1.'_id'");
			builder.append(' ');
			selectDeep = builder.toString();
		}
		return selectDeep;
	}

	protected ScheduledReminder loadCurrentDeep(Cursor cursor, boolean lock) {
		ScheduledReminder entity = loadCurrent(cursor, 0, lock);
		int offset = getAllColumns().length;
		Reminder reminder = loadCurrentOther(daoSession.getReminderDao(), cursor, offset);
		entity.setReminder(reminder);
		offset += daoSession.getReminderDao().getAllColumns().length;
		ElapsedReminder elapsedReminder = loadCurrentOther(
				daoSession.getElapsedReminderDao(), cursor, offset);
		entity.setElapsedReminder(elapsedReminder);
		return entity;
	}

	public ScheduledReminder loadDeep(Long key) {
		assertSinglePk();
		if (key == null) {
			return null;
		}
		StringBuilder builder = new StringBuilder(getSelectDeep());
		builder.append("WHERE ");
		SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
		String sql = builder.toString();
		String[] keyArray = new String[] {key.toString()};
		Cursor cursor = db.rawQuery(sql, keyArray);
		try {
			boolean available = cursor.moveToFirst();
			if (!available) {
				return null;
			} else if (!cursor.isLast()) {
				throw new IllegalStateException("Expected unique result, but count was "
						+ cursor.getCount());
			}
			return loadCurrentDeep(cursor, true);
		} finally {
			cursor.close();
		}
	}

	/** Reads all available rows from the given cursor and returns a list of new ImageTO
	 * objects. */
	public List<ScheduledReminder> loadAllDeepFromCursor(Cursor cursor) {
		int count = cursor.getCount();
		List<ScheduledReminder> list = new ArrayList<ScheduledReminder>(count);
		if (cursor.moveToFirst()) {
			if (identityScope != null) {
				identityScope.lock();
				identityScope.reserveRoom(count);
			}
			try {
				do {
					list.add(loadCurrentDeep(cursor, false));
				} while (cursor.moveToNext());
			} finally {
				if (identityScope != null) {
					identityScope.unlock();
				}
			}
		}
		return list;
	}

	protected List<ScheduledReminder> loadDeepAllAndCloseCursor(Cursor cursor) {
		try {
			return loadAllDeepFromCursor(cursor);
		} finally {
			cursor.close();
		}
	}

	/** A raw-style query where you can pass any WHERE clause and arguments. */
	public List<ScheduledReminder> queryDeep(String where, String... selectionArg) {
		Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
		return loadDeepAllAndCloseCursor(cursor);
	}
}
