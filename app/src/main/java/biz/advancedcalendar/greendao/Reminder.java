package biz.advancedcalendar.greendao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
// KEEP INCLUDES - put your custom includes here
import android.content.Context;
import android.content.res.Resources;
import android.media.RingtoneManager;
import android.os.Parcel;
import android.os.Parcelable;
import android.view.LayoutInflater;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TextView;
import biz.advancedcalendar.alarmer.R;
import biz.advancedcalendar.db.DataProvider;
import biz.advancedcalendar.fragments.FragmentEditTaskPartMain.UserInterfaceData;
import biz.advancedcalendar.greendao.Task.RecurrenceInterval;
import biz.advancedcalendar.utils.Helper;
import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;
import java.text.DateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;

// KEEP INCLUDES END
/** Entity mapped to table REMINDER. */
public class Reminder implements Parcelable {
	private Long id;
	private Long serverId;
	private Long taskId;
	private long localChangeDateTime;
	private long reminderDateTime;
	private byte reminderTimeModeValue;
	/** Not-null value. */
	private String text;
	private boolean enabled;
	private boolean isAlarm;
	private String ringtone;
	private Long ringtoneFadeInTime;
	private Integer playingTime;
	private Integer automaticSnoozeDuration;
	private Integer automaticSnoozesMaxCount;
	private Boolean vibrate;
	private String vibratePattern;
	private Boolean led;
	private String ledPattern;
	private Integer ledColor;
	/** Used to resolve relations */
	private transient DaoSession daoSession;
	/** Used for active entity operations. */
	private transient ReminderDao myDao;
	private Task task;
	private Long task__resolvedKey;
	private List<ScheduledReminder> scheduledReminderList;

	// KEEP FIELDS - put your custom fields here
	private class LongHolder {
		Long value = null;
	}

	public enum AlarmMethod {
		POPUP_WINDOW((byte) 1), STATUS_BAR((byte) 2);
		private byte value;

		private AlarmMethod(byte value) {
			this.value = value;
		}

		public byte getValue() {
			return value;
		}

		private static Map<Byte, AlarmMethod> map = new HashMap<Byte, AlarmMethod>();
		private static Map<String, AlarmMethod> stringToObjectMap = new HashMap<String, AlarmMethod>();
		static {
			for (AlarmMethod alarmMethod : AlarmMethod.values()) {
				AlarmMethod.map.put(alarmMethod.value, alarmMethod);
				AlarmMethod.stringToObjectMap.put(alarmMethod.name(), alarmMethod);
			}
		}

		public static AlarmMethod fromInt(byte value) {
			AlarmMethod alarmMethod = AlarmMethod.map.get(value);
			return alarmMethod;
		}

		public static AlarmMethod fromString(String name) {
			AlarmMethod alarmMethod = AlarmMethod.stringToObjectMap.get(name);
			return alarmMethod;
		}
	}

	public enum ReminderTimeMode {
		ABSOLUTE_TIME((byte) 1, R.id.activity_edit_reminder_radio_reminder_time_absolute), AFTER_NOW(
				(byte) 2, R.id.activity_edit_reminder_radio_reminder_time_after_now), TIME_BEFORE_EVENT(
				(byte) 3, R.id.activity_edit_reminder_radio_reminder_time_before_event), TIME_AFTER_EVENT(
				(byte) 4, R.id.activity_edit_reminder_radio_reminder_time_after_event);
		private byte value;
		private int radioButtonId;

		private ReminderTimeMode(byte value, int radioButtonId) {
			this.value = value;
			this.radioButtonId = radioButtonId;
		}

		public byte getValue() {
			return value;
		}

		public int getRadioButtonId() {
			return radioButtonId;
		}

		private static Map<Byte, ReminderTimeMode> map = new HashMap<Byte, ReminderTimeMode>();
		private static Map<String, ReminderTimeMode> stringToObjectMap = new HashMap<String, ReminderTimeMode>();
		static {
			for (ReminderTimeMode reminderTimeMode : ReminderTimeMode.values()) {
				ReminderTimeMode.map.put(reminderTimeMode.value, reminderTimeMode);
				ReminderTimeMode.stringToObjectMap.put(reminderTimeMode.name(),
						reminderTimeMode);
			}
		}

		public static ReminderTimeMode fromInt(byte value) {
			ReminderTimeMode reminderTimeMode = ReminderTimeMode.map.get(value);
			return reminderTimeMode;
		}

		public static ReminderTimeMode fromString(String name) {
			ReminderTimeMode reminderTimeMode = ReminderTimeMode.stringToObjectMap
					.get(name);
			return reminderTimeMode;
		}
	}

	// KEEP FIELDS END
	public Reminder() {
	}

	public Reminder(Long id) {
		this.id = id;
	}

	public Reminder(Long id, Long serverId, Long taskId, long localChangeDateTime,
			long reminderDateTime, byte reminderTimeModeValue, String text,
			boolean enabled, boolean isAlarm, String ringtone, Long ringtoneFadeInTime,
			Integer playingTime, Integer automaticSnoozeDuration,
			Integer automaticSnoozesMaxCount, Boolean vibrate, String vibratePattern,
			Boolean led, String ledPattern, Integer ledColor) {
		this.id = id;
		this.serverId = serverId;
		this.taskId = taskId;
		this.localChangeDateTime = localChangeDateTime;
		this.reminderDateTime = reminderDateTime;
		this.reminderTimeModeValue = reminderTimeModeValue;
		this.text = text;
		this.enabled = enabled;
		this.isAlarm = isAlarm;
		this.ringtone = ringtone;
		this.ringtoneFadeInTime = ringtoneFadeInTime;
		this.playingTime = playingTime;
		this.automaticSnoozeDuration = automaticSnoozeDuration;
		this.automaticSnoozesMaxCount = automaticSnoozesMaxCount;
		this.vibrate = vibrate;
		this.vibratePattern = vibratePattern;
		this.led = led;
		this.ledPattern = ledPattern;
		this.ledColor = ledColor;
	}

	/** called by internal mechanisms, do not call yourself. */
	public void __setDaoSession(DaoSession daoSession) {
		this.daoSession = daoSession;
		myDao = daoSession != null ? daoSession.getReminderDao() : null;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Long getServerId() {
		return serverId;
	}

	public void setServerId(Long serverId) {
		this.serverId = serverId;
	}

	public Long getTaskId() {
		return taskId;
	}

	public void setTaskId(Long taskId) {
		this.taskId = taskId;
	}

	public long getLocalChangeDateTime() {
		return localChangeDateTime;
	}

	public void setLocalChangeDateTime(long localChangeDateTime) {
		this.localChangeDateTime = localChangeDateTime;
	}

	public long getReminderDateTime() {
		return reminderDateTime;
	}

	public void setReminderDateTime(long reminderDateTime) {
		this.reminderDateTime = reminderDateTime;
	}

	public byte getReminderTimeModeValue() {
		return reminderTimeModeValue;
	}

	public void setReminderTimeModeValue(byte reminderTimeModeValue) {
		this.reminderTimeModeValue = reminderTimeModeValue;
	}

	/** Not-null value. */
	public String getText() {
		return text;
	}

	/** Not-null value; ensure this value is available before it is saved to the database. */
	public void setText(String text) {
		this.text = text;
	}

	public boolean getEnabled() {
		return enabled;
	}

	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}

	public boolean getIsAlarm() {
		return isAlarm;
	}

	public void setIsAlarm(boolean isAlarm) {
		this.isAlarm = isAlarm;
	}

	public String getRingtone() {
		return ringtone;
	}

	public void setRingtone(String ringtone) {
		this.ringtone = ringtone;
	}

	public Long getRingtoneFadeInTime() {
		return ringtoneFadeInTime;
	}

	public void setRingtoneFadeInTime(Long ringtoneFadeInTime) {
		this.ringtoneFadeInTime = ringtoneFadeInTime;
	}

	public Integer getPlayingTime() {
		return playingTime;
	}

	public void setPlayingTime(Integer playingTime) {
		this.playingTime = playingTime;
	}

	public Integer getAutomaticSnoozeDuration() {
		return automaticSnoozeDuration;
	}

	public void setAutomaticSnoozeDuration(Integer automaticSnoozeDuration) {
		this.automaticSnoozeDuration = automaticSnoozeDuration;
	}

	public Integer getAutomaticSnoozesMaxCount() {
		return automaticSnoozesMaxCount;
	}

	public void setAutomaticSnoozesMaxCount(Integer automaticSnoozesMaxCount) {
		this.automaticSnoozesMaxCount = automaticSnoozesMaxCount;
	}

	public Boolean getVibrate() {
		return vibrate;
	}

	public void setVibrate(Boolean vibrate) {
		this.vibrate = vibrate;
	}

	public String getVibratePattern() {
		return vibratePattern;
	}

	public void setVibratePattern(String vibratePattern) {
		this.vibratePattern = vibratePattern;
	}

	public Boolean getLed() {
		return led;
	}

	public void setLed(Boolean led) {
		this.led = led;
	}

	public String getLedPattern() {
		return ledPattern;
	}

	public void setLedPattern(String ledPattern) {
		this.ledPattern = ledPattern;
	}

	public Integer getLedColor() {
		return ledColor;
	}

	public void setLedColor(Integer ledColor) {
		this.ledColor = ledColor;
	}

	/** To-one relationship, resolved on first access. */
	public Task getTask() {
		Long __key = taskId;
		if (task__resolvedKey == null || !task__resolvedKey.equals(__key)) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			TaskDao targetDao = daoSession.getTaskDao();
			Task taskNew = targetDao.load(__key);
			synchronized (this) {
				task = taskNew;
				task__resolvedKey = __key;
			}
		}
		return task;
	}

	public void setTask(Task task) {
		synchronized (this) {
			this.task = task;
			taskId = task == null ? null : task.getId();
			task__resolvedKey = taskId;
		}
	}

	/** To-many relationship, resolved on first access (and after reset). Changes to
	 * to-many relations are not persisted, make changes to the target entity. */
	public List<ScheduledReminder> getScheduledReminderList() {
		if (scheduledReminderList == null) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			ScheduledReminderDao targetDao = daoSession.getScheduledReminderDao();
			List<ScheduledReminder> scheduledReminderListNew = targetDao
					._queryReminder_ScheduledReminderList(id);
			synchronized (this) {
				if (scheduledReminderList == null) {
					scheduledReminderList = scheduledReminderListNew;
				}
			}
		}
		return scheduledReminderList;
	}

	/** Resets a to-many relationship, making the next get call to query for a fresh
	 * result. */
	public synchronized void resetScheduledReminderList() {
		scheduledReminderList = null;
	}

	/** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an
	 * entity context. */
	public void delete() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.delete(this);
	}

	/** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an
	 * entity context. */
	public void update() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.update(this);
	}

	/** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an
	 * entity context. */
	public void refresh() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.refresh(this);
	}

	// KEEP METHODS - put your custom methods here
	public Reminder(Reminder r) {
		this(r.id, r.serverId, r.taskId, r.localChangeDateTime, r.reminderDateTime,
				r.reminderTimeModeValue, r.text, r.enabled, r.isAlarm, r.ringtone,
				r.ringtoneFadeInTime, r.playingTime, r.automaticSnoozeDuration,
				r.automaticSnoozesMaxCount, r.vibrate, r.vibratePattern, r.led,
				r.ledPattern, r.ledColor);
	}

	public String getTextForAbsoluteTime() {
		DateFormat mDateFormat = DateFormat.getDateTimeInstance();
		String dateString = mDateFormat.format(new Date(reminderDateTime));
		return dateString;
	}

	public String getTextForAbsoluteTime(long reminderDateTime) {
		DateFormat mDateFormat = DateFormat.getDateTimeInstance();
		String dateString = mDateFormat.format(new Date(reminderDateTime));
		return dateString;
	}

	public void generateTableRow(TableLayout tableLayout, LayoutInflater mLayoutInflater,
			Resources resources, int headerStringId, String text) {
		TableRow tableRow = (TableRow) mLayoutInflater.inflate(
				R.layout.fragment_view_task_part_main_table_row, tableLayout, false);
		TextView textViewHeader = (TextView) tableRow
				.findViewById(R.id.fragment_view_task_part_main_tablerow_left_textview);
		textViewHeader.setText(resources.getString(headerStringId));
		TextView textViewValue = (TextView) tableRow
				.findViewById(R.id.fragment_view_task_part_main_tablerow_right_textview);
		textViewValue.setText(text);
		tableLayout.addView(tableRow);
	}

	public String getTextForReminderTimeIntervalAndTimeModeAndNextAlarmTime(
			Context context, UserInterfaceData userInterfaceData) {
		Resources resources = context.getResources();
		long now = System.currentTimeMillis();
		String textForReminderTimeIntervalAndTimeMode;
		if (reminderDateTime == 0) {
			textForReminderTimeIntervalAndTimeMode = resources
					.getString(R.string.fragment_view_task_part_reminders_value_textview_reminder_time_type_at_task_start);
		} else {
			long absRemindOffset = Math.abs(reminderDateTime);
			String textForTimeInterval = Helper.getTextForTimeInterval(context,
					absRemindOffset);
			String textForReminderTimeMode = reminderDateTime > 0
					&& reminderTimeModeValue == ReminderTimeMode.TIME_BEFORE_EVENT
							.getValue()
					|| reminderDateTime < 0
					&& reminderTimeModeValue == ReminderTimeMode.TIME_AFTER_EVENT
							.getValue() ? resources
					.getString(R.string.fragment_view_task_part_reminders_value_textview_reminder_time_type_before_task_start)
					: resources
							.getString(R.string.fragment_view_task_part_reminders_value_textview_reminder_time_type_after_task_start);
			textForReminderTimeIntervalAndTimeMode = String.format(resources
					.getString(R.string.text_for_reminder_time_interval_and_time_mode),
					textForTimeInterval, textForReminderTimeMode);
		}
		Long nextReminderDateTime;
		if (userInterfaceData.startDateTime != null) {
			if (userInterfaceData.recurrenceInterval == RecurrenceInterval.ONE_TIME) {
				if (ReminderTimeMode.fromInt(reminderTimeModeValue) == ReminderTimeMode.TIME_BEFORE_EVENT) {
					nextReminderDateTime = userInterfaceData.startDateTime
							- reminderDateTime;
				} else {
					nextReminderDateTime = userInterfaceData.startDateTime
							+ reminderDateTime;
				}
				if (nextReminderDateTime <= now) {
					nextReminderDateTime = null;
				}
			} else {
				nextReminderDateTime = getNextReminderDateTime(context, now, true,
						Helper.getFirstDayOfWeek(context));
			}
		} else {
			nextReminderDateTime = null;
		}
		String timeText;
		if (nextReminderDateTime != null) {
			timeText = getTextForAbsoluteTime(nextReminderDateTime);
		} else {
			timeText = resources
					.getString(R.string.fragment_view_task_part_reminders_value_textview_reminder_time_next_reminder_time_none);
		}
		String textNextAlarmTime = String
				.format(resources
						.getString(R.string.fragment_view_task_part_reminders_text_next_alarm_time),
						timeText);
		String textForReminderTimeIntervalAndTimeModeAndNextAlarmTime = String
				.format(resources
						.getString(R.string.text_for_reminder_time_interval_and_time_mode_and_next_alarm_time),
						textForReminderTimeIntervalAndTimeMode, textNextAlarmTime);
		return textForReminderTimeIntervalAndTimeModeAndNextAlarmTime;
	}

	// public Task getTask2(Context context) {
	// return DataProvider.getTask(context, TaskId, false);
	// }
	public List<ScheduledReminder> getScheduledReminderList(Context context, int[] states) {
		if (daoSession != null && states == null) {
			return getScheduledReminderList();
		}
		return DataProvider.getScheduledReminders(null, context, id, states);
	}

	public Long getNextReminderDateTime(final Context context,
			final long controlDateTime,
			final boolean includeEventsMatchingControlDateTime, final int firstDayOfWeek) {
		if (reminderTimeModeValue == ReminderTimeMode.ABSOLUTE_TIME.getValue()) {
			if (reminderDateTime < controlDateTime) {
				return null;
			} else {
				return reminderDateTime;
			}
		}
		final LongHolder resultReminderDateTime = new LongHolder();
		DataProvider.runInTx(null, context, new Runnable() {
			@Override
			public void run() {
				Task task = getTask();
				Long occurrenceStartDateTime;
				long controlDateTime2;
				long supposedResultReminderDateTime;
				// check PreviousRepetitionStartDateTime
				if (ReminderTimeMode.fromInt(reminderTimeModeValue).equals(
						ReminderTimeMode.TIME_AFTER_EVENT)) {
					occurrenceStartDateTime = task.getNearestOccurrenceStartDateTime(
							controlDateTime, includeEventsMatchingControlDateTime, true,
							firstDayOfWeek);
					if (occurrenceStartDateTime != null) {
						supposedResultReminderDateTime = occurrenceStartDateTime
								+ reminderDateTime;
						if (includeEventsMatchingControlDateTime
								&& supposedResultReminderDateTime >= controlDateTime
								|| !includeEventsMatchingControlDateTime
								&& supposedResultReminderDateTime > controlDateTime) {
							resultReminderDateTime.value = supposedResultReminderDateTime;
							// check for the earliest suitable recurrence of the task
							controlDateTime2 = occurrenceStartDateTime;
							while (true) {
								occurrenceStartDateTime = task
										.getNearestOccurrenceStartDateTime(
												controlDateTime2, false, true,
												firstDayOfWeek);
								if (occurrenceStartDateTime == null) {
									return;
								}
								supposedResultReminderDateTime = occurrenceStartDateTime
										+ reminderDateTime;
								if (includeEventsMatchingControlDateTime
										&& supposedResultReminderDateTime >= controlDateTime
										|| !includeEventsMatchingControlDateTime
										&& supposedResultReminderDateTime > controlDateTime) {
									resultReminderDateTime.value = supposedResultReminderDateTime;
								}
								controlDateTime2 = occurrenceStartDateTime;
							}
						}
					}
				}
				// check NextRepetitionStartDateTime
				controlDateTime2 = includeEventsMatchingControlDateTime ? controlDateTime - 1
						: controlDateTime;
				while (true) {
					occurrenceStartDateTime = task.getNearestOccurrenceStartDateTime(
							controlDateTime2, false, false, firstDayOfWeek);
					if (occurrenceStartDateTime == null) {
						resultReminderDateTime.value = null;
						return;
					}
					supposedResultReminderDateTime = occurrenceStartDateTime
							- (reminderTimeModeValue == ReminderTimeMode.TIME_BEFORE_EVENT
									.getValue() ? reminderDateTime : -reminderDateTime);
					if (includeEventsMatchingControlDateTime
							&& supposedResultReminderDateTime >= controlDateTime
							|| !includeEventsMatchingControlDateTime
							&& supposedResultReminderDateTime > controlDateTime) {
						resultReminderDateTime.value = supposedResultReminderDateTime;
						return;
					}
					controlDateTime2 = occurrenceStartDateTime;
				}
			}
		});
		return resultReminderDateTime.value;
	}

	// public Long getPreviousReminderDateTime(final Context context,
	// final long controlDateTime,
	// final boolean includeEventsMatchingControlDateTime, final int firstDayOfWeek) {
	// if (ReminderTimeMode == ReminderTimeMode.ABSOLUTE_TIME.getValue()) {
	// if (ReminderDateTime >= controlDateTime) {
	// return null;
	// } else {
	// return ReminderDateTime;
	// }
	// }
	// final LongHolder resultReminderDateTime = new LongHolder();
	// DataProvider.runInTx(context, new Runnable() {
	// @Override
	// public void run() {
	// Task task = getTask();
	// if (task.getTimeUnitsCount() == null) {
	// if (task.getStartDateTime() == null) {
	// resultReminderDateTime.value = null;
	// } else {
	// resultReminderDateTime.value = task.getStartDateTime()
	// - (ReminderDateTime > 0
	// && ReminderTimeMode == ReminderTimeMode.TIME_BEFORE_EVENT
	// .getValue()
	// || ReminderDateTime < 0
	// && ReminderTimeMode == ReminderTimeMode.TIME_AFTER_EVENT
	// .getValue() ? ReminderDateTime
	// : -ReminderDateTime);
	// if (resultReminderDateTime.value >= controlDateTime) {
	// resultReminderDateTime.value = null;
	// }
	// }
	// return;
	// } else {
	// Long eventStartDateTime = task.getPreviousOccurrenceStartDateTime(
	// context, controlDateTime, false, firstDayOfWeek);
	// if (eventStartDateTime == null) {
	// eventStartDateTime = task.getNextOccurrenceStartDateTime(context,
	// controlDateTime, true, firstDayOfWeek);
	// }
	// if (eventStartDateTime == null) {
	// resultReminderDateTime.value = null;
	// return;
	// }
	// resultReminderDateTime.value = eventStartDateTime
	// - (ReminderDateTime > 0
	// && ReminderTimeMode == ReminderTimeMode.TIME_BEFORE_EVENT
	// .getValue()
	// || ReminderDateTime < 0
	// && ReminderTimeMode == ReminderTimeMode.TIME_AFTER_EVENT
	// .getValue() ? ReminderDateTime
	// : -ReminderDateTime);
	// if (resultReminderDateTime.value >= controlDateTime) {
	// resultReminderDateTime.value = null;
	// return;
	// }
	// Long eventStartDateTime2;
	// long reminderDateTime;
	// while (true) {
	// eventStartDateTime2 = task.getNextOccurrenceStartDateTime(
	// context, eventStartDateTime, true, firstDayOfWeek);
	// if (eventStartDateTime2 == null) {
	// return;
	// }
	// reminderDateTime = eventStartDateTime2
	// - (ReminderDateTime > 0
	// && ReminderTimeMode == ReminderTimeMode.TIME_BEFORE_EVENT
	// .getValue()
	// || ReminderDateTime < 0
	// && ReminderTimeMode == ReminderTimeMode.TIME_AFTER_EVENT
	// .getValue() ? ReminderDateTime
	// : -ReminderDateTime);
	// if (reminderDateTime >= controlDateTime
	// || eventStartDateTime2 == eventStartDateTime) {
	// return;
	// } else {
	// eventStartDateTime = eventStartDateTime2;
	// resultReminderDateTime.value = reminderDateTime;
	// }
	// }
	// }
	// }
	// });
	// return resultReminderDateTime.value;
	// }
	public String getRingtone2(final Context context, final int preferenceId) {
		try {
			return DataProvider.callInTx(null, context, new Callable<String>() {
				@Override
				public String call() {
					if (ringtone != null) {
						return ringtone;
					} else {
						Task task = getTask();
						if (task != null) {
							return task.getRingtone2(context, preferenceId);
						} else {
							return Helper.getStringPreferenceValue(
									context,
									preferenceId,
									RingtoneManager.getDefaultUri(
											isAlarm ? RingtoneManager.TYPE_ALARM
													: RingtoneManager.TYPE_NOTIFICATION)
											.toString());
						}
					}
				}
			});
		} catch (Exception e) {
			return null;
		}
	}

	public String getRingtoneTitle(Context context) {
		int preferenceId = isAlarm ? R.string.preference_key_alarm_ringtone
				: R.string.preference_key_notification_ringtone;
		String ringtoneString = getRingtone2(context, preferenceId);
		return Helper.getRingtoneTitle(context, ringtoneString);
	}

	// public String getRingtoneTitlePreviousVersion(final Context context) {
	// String ringtoneTitle = null;
	// try {
	// ringtoneTitle = DataProvider.callInTx(context, new Callable<String>() {
	// @Override
	// public String call() {
	// String ringtoneTitle;
	// String ringtoneString;
	// if (Ringtone == null) {
	// Task task = DataProvider.getTask(context, TaskId, false);
	// if (task != null) {
	// ringtoneTitle = IsAlarm ? task.getAlarmRingtoneTitle(context)
	// : task.getNotificationRingtoneTitle(context);
	// } else {
	// ringtoneString = Helper
	// .getStringPreferenceValue(
	// context,
	// IsAlarm ? R.string.preference_key_alarm_ringtone
	// : R.string.preference_key_notification_ringtone,
	// RingtoneManager
	// .getRingtone(
	// context,
	// RingtoneManager
	// .getDefaultUri(IsAlarm ? RingtoneManager.TYPE_ALARM
	// : RingtoneManager.TYPE_NOTIFICATION))
	// .getTitle(context));
	// if (ringtoneString.length() == 0) {
	// ringtoneTitle = context.getResources().getString(
	// R.string.ringtone_silent);
	// } else {
	// ringtoneTitle = RingtoneManager.getRingtone(context,
	// Uri.parse(ringtoneString)).getTitle(context);
	// }
	// }
	// } else if (Ringtone.length() == 0) {
	// ringtoneTitle = context.getResources().getString(
	// R.string.ringtone_silent);
	// } else {
	// Ringtone ringtone = RingtoneManager.getRingtone(context,
	// Uri.parse(Ringtone));
	// if (ringtone != null) {
	// ringtoneTitle = ringtone.getTitle(context);
	// } else {
	// Task task = DataProvider.getTask(context, TaskId, false);
	// if (task != null) {
	// ringtoneTitle = IsAlarm ? task
	// .getAlarmRingtoneTitle(context) : task
	// .getNotificationRingtoneTitle(context);
	// } else {
	// ringtoneString = Helper
	// .getStringPreferenceValue(
	// context,
	// IsAlarm ? R.string.preference_key_alarm_ringtone
	// : R.string.preference_key_notification_ringtone,
	// RingtoneManager
	// .getRingtone(
	// context,
	// RingtoneManager
	// .getDefaultUri(IsAlarm ? RingtoneManager.TYPE_ALARM
	// : RingtoneManager.TYPE_NOTIFICATION))
	// .getTitle(context));
	// if (ringtoneString.length() == 0) {
	// ringtoneTitle = context.getResources().getString(
	// R.string.ringtone_silent);
	// } else {
	// ringtoneTitle = RingtoneManager.getRingtone(context,
	// Uri.parse(ringtoneString)).getTitle(context);
	// }
	// }
	// }
	// }
	// return ringtoneTitle;
	// }
	// });
	// } catch (Exception e) {
	// e.printStackTrace();
	// }
	// return ringtoneTitle;
	// }
	public long getRingtoneFadeInTime2(Context context, int preferenceKey,
			long defaultValue, Long minValue, Long maxValue) {
		if (ringtoneFadeInTime != null) {
			return ringtoneFadeInTime;
		}
		Task task = getTask();
		if (task != null) {
			return task.getRingtoneFadeInTime2(context, preferenceKey, defaultValue,
					minValue, maxValue);
		}
		return Helper.getLongFromStringPreferenceValue(context, preferenceKey,
				defaultValue, minValue, maxValue);
	}

	public int getPlayingTime2(Context context, int preferenceKey, int defaultValue,
			Integer minValue, Integer maxValue) {
		if (playingTime != null) {
			return playingTime;
		}
		Task task = getTask();
		if (task != null) {
			return task.getPlayingTime2(context, preferenceKey, defaultValue, minValue,
					maxValue);
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey, null,
				defaultValue, minValue, maxValue);
	}

	public int getAutomaticSnoozeDuration2(Context context, int preferenceKey,
			int defaultValue, Integer minValue, Integer maxValue) {
		if (automaticSnoozeDuration != null) {
			return automaticSnoozeDuration;
		}
		Task task = getTask();
		if (task != null) {
			return task.getAutomaticSnoozeDuration2(context, preferenceKey, defaultValue,
					minValue, maxValue);
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey, null,
				defaultValue, minValue, maxValue);
	}

	public int getAutomaticSnoozesMaxCount2(Context context, int preferenceKey,
			int defaultValue, Integer minValue, Integer maxValue) {
		if (automaticSnoozesMaxCount != null) {
			return automaticSnoozesMaxCount;
		}
		Task task = getTask();
		if (task != null) {
			return task.getAutomaticSnoozesMaxCount2(context, preferenceKey,
					defaultValue, minValue, maxValue);
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey, null,
				defaultValue, minValue, maxValue);
	}

	public boolean getVibrate2(Context context, String preferenceKey, boolean defaultValue) {
		if (vibrate != null) {
			return vibrate;
		}
		Task task = getTask();
		if (task != null) {
			return task.getVibrate2(context, preferenceKey, defaultValue);
		}
		return Helper.getBooleanPreferenceValue(context, preferenceKey, defaultValue);
	}

	protected Reminder(Parcel in) {
		id = in.readByte() == 0x00 ? null : in.readLong();
		serverId = in.readByte() == 0x00 ? null : in.readLong();
		taskId = in.readByte() == 0x00 ? null : in.readLong();
		localChangeDateTime = in.readLong();
		reminderDateTime = in.readLong();
		reminderTimeModeValue = in.readByte();
		text = in.readString();
		enabled = in.readByte() != 0x00;
		isAlarm = in.readByte() != 0x00;
		ringtone = in.readString();
		ringtoneFadeInTime = in.readByte() == 0x00 ? null : in.readLong();
		playingTime = in.readByte() == 0x00 ? null : in.readInt();
		automaticSnoozeDuration = in.readByte() == 0x00 ? null : in.readInt();
		automaticSnoozesMaxCount = in.readByte() == 0x00 ? null : in.readInt();
		byte vibrateVal = in.readByte();
		vibrate = vibrateVal == 0x02 ? null : vibrateVal != 0x00;
		vibratePattern = in.readString();
		byte ledVal = in.readByte();
		led = ledVal == 0x02 ? null : ledVal != 0x00;
		ledPattern = in.readString();
		ledColor = in.readByte() == 0x00 ? null : in.readInt();
	}

	@Override
	public int describeContents() {
		return 0;
	}

	@Override
	public void writeToParcel(Parcel dest, int flags) {
		if (id == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(id);
		}
		if (serverId == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(serverId);
		}
		if (taskId == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(taskId);
		}
		dest.writeLong(localChangeDateTime);
		dest.writeLong(reminderDateTime);
		dest.writeByte(reminderTimeModeValue);
		dest.writeString(text);
		dest.writeByte((byte) (enabled ? 0x01 : 0x00));
		dest.writeByte((byte) (isAlarm ? 0x01 : 0x00));
		dest.writeString(ringtone);
		if (ringtoneFadeInTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(ringtoneFadeInTime);
		}
		if (playingTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(playingTime);
		}
		if (automaticSnoozeDuration == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(automaticSnoozeDuration);
		}
		if (automaticSnoozesMaxCount == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(automaticSnoozesMaxCount);
		}
		if (vibrate == null) {
			dest.writeByte((byte) 0x02);
		} else {
			dest.writeByte((byte) (vibrate ? 0x01 : 0x00));
		}
		dest.writeString(vibratePattern);
		if (led == null) {
			dest.writeByte((byte) 0x02);
		} else {
			dest.writeByte((byte) (led ? 0x01 : 0x00));
		}
		dest.writeString(ledPattern);
		if (ledColor == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(ledColor);
		}
	}

	public static final Parcelable.Creator<Reminder> CREATOR = new Parcelable.Creator<Reminder>() {
		@Override
		public Reminder createFromParcel(Parcel in) {
			return new Reminder(in);
		}

		@Override
		public Reminder[] newArray(int size) {
			return new Reminder[size];
		}
	};
	// KEEP METHODS END
}
