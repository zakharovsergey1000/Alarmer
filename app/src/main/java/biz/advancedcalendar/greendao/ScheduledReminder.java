package biz.advancedcalendar.greendao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
// KEEP INCLUDES - put your custom includes here
import android.content.Context;
import android.media.RingtoneManager;
import android.os.Parcel;
import android.os.Parcelable;

import biz.advancedcalendar.alarmer.R;
import biz.advancedcalendar.db.DataProvider;
import biz.advancedcalendar.utils.Helper;
import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;
import de.greenrobot.dao.query.QueryBuilder;
import java.util.HashMap;
import java.util.Map;

// KEEP INCLUDES END
/** Entity mapped to table SCHEDULED_REMINDER. */
public class ScheduledReminder implements Parcelable {
	private Long id;
	private Long reminderId;
	private Long elapsedReminderId;
	private boolean isQuickReminder;
	private long assignedRemindAtDateTime;
	private long nextSnoozeDateTime;
	private Long actualLastAlarmedDateTime;
	private int snoozeCount;
	private int stateValue;
	/** Not-null value. */
	private String text;
	private boolean isAlarm;
	private boolean enabled;
	private String ringtone;
	private Long ringtoneFadeInTime;
	private Integer playingTime;
	private Integer automaticSnoozeDuration;
	private Integer automaticSnoozesMaxCount;
	private Boolean vibrate;
	private String vibratePattern;
	private Boolean led;
	private String ledPattern;
	private Integer ledColor;
	/** Used to resolve relations */
	private transient DaoSession daoSession;
	/** Used for active entity operations. */
	private transient ScheduledReminderDao myDao;
	private Reminder reminder;
	private Long reminder__resolvedKey;
	private ElapsedReminder elapsedReminder;
	private Long elapsedReminder__resolvedKey;

	// KEEP FIELDS - put your custom fields here
	public static enum State {
		SCHEDULED(1), ALARMED(2);
		private int value;

		private State(int value) {
			this.value = value;
		}

		public int getValue() {
			return value;
		}

		private static Map<Integer, State> map = new HashMap<Integer, State>();
		static {
			for (State state : State.values()) {
				State.map.put(state.value, state);
			}
		}

		public static State fromInt(int value) {
			State state = State.map.get(value);
			return state;
		}
	}

	// KEEP FIELDS END
	public ScheduledReminder() {
	}

	public ScheduledReminder(Long id) {
		this.id = id;
	}

	public ScheduledReminder(Long id, Long reminderId, Long elapsedReminderId,
			boolean isQuickReminder, long assignedRemindAtDateTime,
			long nextSnoozeDateTime, Long actualLastAlarmedDateTime, int snoozeCount,
			int stateValue, String text, boolean isAlarm, boolean enabled,
			String ringtone, Long ringtoneFadeInTime, Integer playingTime,
			Integer automaticSnoozeDuration, Integer automaticSnoozesMaxCount,
			Boolean vibrate, String vibratePattern, Boolean led, String ledPattern,
			Integer ledColor) {
		this.id = id;
		this.reminderId = reminderId;
		this.elapsedReminderId = elapsedReminderId;
		this.isQuickReminder = isQuickReminder;
		this.assignedRemindAtDateTime = assignedRemindAtDateTime;
		this.nextSnoozeDateTime = nextSnoozeDateTime;
		this.actualLastAlarmedDateTime = actualLastAlarmedDateTime;
		this.snoozeCount = snoozeCount;
		this.stateValue = stateValue;
		this.text = text;
		this.isAlarm = isAlarm;
		this.enabled = enabled;
		this.ringtone = ringtone;
		this.ringtoneFadeInTime = ringtoneFadeInTime;
		this.playingTime = playingTime;
		this.automaticSnoozeDuration = automaticSnoozeDuration;
		this.automaticSnoozesMaxCount = automaticSnoozesMaxCount;
		this.vibrate = vibrate;
		this.vibratePattern = vibratePattern;
		this.led = led;
		this.ledPattern = ledPattern;
		this.ledColor = ledColor;
	}

	/** called by internal mechanisms, do not call yourself. */
	public void __setDaoSession(DaoSession daoSession) {
		this.daoSession = daoSession;
		myDao = daoSession != null ? daoSession.getScheduledReminderDao() : null;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Long getReminderId() {
		return reminderId;
	}

	public void setReminderId(Long reminderId) {
		this.reminderId = reminderId;
	}

	public Long getElapsedReminderId() {
		return elapsedReminderId;
	}

	public void setElapsedReminderId(Long elapsedReminderId) {
		this.elapsedReminderId = elapsedReminderId;
	}

	public boolean getIsQuickReminder() {
		return isQuickReminder;
	}

	public void setIsQuickReminder(boolean isQuickReminder) {
		this.isQuickReminder = isQuickReminder;
	}

	public long getAssignedRemindAtDateTime() {
		return assignedRemindAtDateTime;
	}

	public void setAssignedRemindAtDateTime(long assignedRemindAtDateTime) {
		this.assignedRemindAtDateTime = assignedRemindAtDateTime;
	}

	public long getNextSnoozeDateTime() {
		return nextSnoozeDateTime;
	}

	public void setNextSnoozeDateTime(long nextSnoozeDateTime) {
		this.nextSnoozeDateTime = nextSnoozeDateTime;
	}

	public Long getActualLastAlarmedDateTime() {
		return actualLastAlarmedDateTime;
	}

	public void setActualLastAlarmedDateTime(Long actualLastAlarmedDateTime) {
		this.actualLastAlarmedDateTime = actualLastAlarmedDateTime;
	}

	public int getSnoozeCount() {
		return snoozeCount;
	}

	public void setSnoozeCount(int snoozeCount) {
		this.snoozeCount = snoozeCount;
	}

	public int getStateValue() {
		return stateValue;
	}

	public void setStateValue(int stateValue) {
		this.stateValue = stateValue;
	}

	/** Not-null value. */
	public String getText() {
		return text;
	}

	/** Not-null value; ensure this value is available before it is saved to the database. */
	public void setText(String text) {
		this.text = text;
	}

	public boolean getIsAlarm() {
		return isAlarm;
	}

	public void setIsAlarm(boolean isAlarm) {
		this.isAlarm = isAlarm;
	}

	public boolean getEnabled() {
		return enabled;
	}

	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}

	public String getRingtone() {
		return ringtone;
	}

	public void setRingtone(String ringtone) {
		this.ringtone = ringtone;
	}

	public Long getRingtoneFadeInTime() {
		return ringtoneFadeInTime;
	}

	public void setRingtoneFadeInTime(Long ringtoneFadeInTime) {
		this.ringtoneFadeInTime = ringtoneFadeInTime;
	}

	public Integer getPlayingTime() {
		return playingTime;
	}

	public void setPlayingTime(Integer playingTime) {
		this.playingTime = playingTime;
	}

	public Integer getAutomaticSnoozeDuration() {
		return automaticSnoozeDuration;
	}

	public void setAutomaticSnoozeDuration(Integer automaticSnoozeDuration) {
		this.automaticSnoozeDuration = automaticSnoozeDuration;
	}

	public Integer getAutomaticSnoozesMaxCount() {
		return automaticSnoozesMaxCount;
	}

	public void setAutomaticSnoozesMaxCount(Integer automaticSnoozesMaxCount) {
		this.automaticSnoozesMaxCount = automaticSnoozesMaxCount;
	}

	public Boolean getVibrate() {
		return vibrate;
	}

	public void setVibrate(Boolean vibrate) {
		this.vibrate = vibrate;
	}

	public String getVibratePattern() {
		return vibratePattern;
	}

	public void setVibratePattern(String vibratePattern) {
		this.vibratePattern = vibratePattern;
	}

	public Boolean getLed() {
		return led;
	}

	public void setLed(Boolean led) {
		this.led = led;
	}

	public String getLedPattern() {
		return ledPattern;
	}

	public void setLedPattern(String ledPattern) {
		this.ledPattern = ledPattern;
	}

	public Integer getLedColor() {
		return ledColor;
	}

	public void setLedColor(Integer ledColor) {
		this.ledColor = ledColor;
	}

	/** To-one relationship, resolved on first access. */
	public Reminder getReminder() {
		Long __key = reminderId;
		if (reminder__resolvedKey == null || !reminder__resolvedKey.equals(__key)) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			ReminderDao targetDao = daoSession.getReminderDao();
			Reminder reminderNew = targetDao.load(__key);
			synchronized (this) {
				reminder = reminderNew;
				reminder__resolvedKey = __key;
			}
		}
		return reminder;
	}

	public void setReminder(Reminder reminder) {
		synchronized (this) {
			this.reminder = reminder;
			reminderId = reminder == null ? null : reminder.getId();
			reminder__resolvedKey = reminderId;
		}
	}

	/** To-one relationship, resolved on first access. */
	public ElapsedReminder getElapsedReminder() {
		Long __key = elapsedReminderId;
		if (elapsedReminder__resolvedKey == null
				|| !elapsedReminder__resolvedKey.equals(__key)) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			ElapsedReminderDao targetDao = daoSession.getElapsedReminderDao();
			ElapsedReminder elapsedReminderNew = targetDao.load(__key);
			synchronized (this) {
				elapsedReminder = elapsedReminderNew;
				elapsedReminder__resolvedKey = __key;
			}
		}
		return elapsedReminder;
	}

	public void setElapsedReminder(ElapsedReminder elapsedReminder) {
		synchronized (this) {
			this.elapsedReminder = elapsedReminder;
			elapsedReminderId = elapsedReminder == null ? null : elapsedReminder.getId();
			elapsedReminder__resolvedKey = elapsedReminderId;
		}
	}

	/** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an
	 * entity context. */
	public void delete() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.delete(this);
	}

	/** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an
	 * entity context. */
	public void update() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.update(this);
	}

	/** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an
	 * entity context. */
	public void refresh() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.refresh(this);
	}

	// KEEP METHODS - put your custom methods here
	public Reminder getReminder(DaoSession daoSession) {
		if (reminderId == null) {
			return null;
		}
		ReminderDao dao = daoSession.getReminderDao();
		QueryBuilder<Reminder> qb = dao.queryBuilder();
		qb.where(ReminderDao.Properties.Id.eq(reminderId));
		Reminder entity = qb.unique();
		return entity;
	}

	public String getRingtone(Context context, DaoSession daoSession) {
		if (ringtone != null) {
			return ringtone;
		} else {
			int preferenceId;
			int ringtoneType;
			if (isAlarm) {
				preferenceId = R.string.preference_key_alarm_ringtone;
				ringtoneType = RingtoneManager.TYPE_ALARM;
			} else {
				preferenceId = R.string.preference_key_notification_ringtone;
				ringtoneType = RingtoneManager.TYPE_NOTIFICATION;
			}
			Reminder reminder = getReminder(daoSession);
			if (reminder != null) {
				return reminder.getRingtone2(context, preferenceId);
			} else {
				return Helper.getStringPreferenceValue(context, context.getResources()
						.getString(preferenceId),
						RingtoneManager.getDefaultUri(ringtoneType).toString());
			}
		}
	}

	public String getRingtoneTitle(Context context, DaoSession daoSession) {
		return Helper.getRingtoneTitle(context, getRingtone(context, daoSession));
	}

	public long getRingtoneFadeInTime2(Context context, int preferenceKey,
			long defaultValue, Long minValue, Long maxValue) {
		if (ringtoneFadeInTime != null) {
			return ringtoneFadeInTime;
		}
		Reminder reminder = DataProvider.getReminder(null, context, reminderId);
		if (reminder != null) {
			return reminder.getRingtoneFadeInTime2(context, preferenceKey, defaultValue,
					minValue, maxValue);
		}
		return Helper.getLongFromStringPreferenceValue(context, preferenceKey,
				defaultValue, minValue, maxValue);
	}

	public int getPlayingTime2(Context context, int preferenceKey, int defaultValue,
			Integer minValue, Integer maxValue) {
		if (playingTime != null) {
			return playingTime;
		}
		Reminder reminder = DataProvider.getReminder(null, context, reminderId);
		if (reminder != null) {
			return reminder.getPlayingTime2(context, preferenceKey, defaultValue,
					minValue, maxValue);
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey,
				null, defaultValue, minValue, maxValue);
	}

	public int getAutomaticSnoozeDuration2(Context context, int preferenceKey,
			int defaultValue, Integer minValue, Integer maxValue) {
		if (automaticSnoozeDuration != null) {
			return automaticSnoozeDuration;
		}
		Reminder reminder = DataProvider.getReminder(null, context, reminderId);
		if (reminder != null) {
			return reminder.getAutomaticSnoozeDuration2(context, preferenceKey,
					defaultValue, minValue, maxValue);
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey,
				null, defaultValue, minValue, maxValue);
	}

	public int getAutomaticSnoozesMaxCount2(Context context, int preferenceKey,
			int defaultValue, Integer minValue, Integer maxValue) {
		if (automaticSnoozesMaxCount != null) {
			return automaticSnoozesMaxCount;
		}
		Reminder reminder = DataProvider.getReminder(null, context, reminderId);
		if (reminder != null) {
			return reminder.getAutomaticSnoozesMaxCount2(context, preferenceKey,
					defaultValue, minValue, maxValue);
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey,
				null, defaultValue, minValue, maxValue);
	}

	public boolean getVibrate2(Context context, String preferenceKey, boolean defaultValue) {
		if (vibrate != null) {
			return vibrate;
		}
		Reminder reminder = DataProvider.getReminder(null, context, reminderId);
		if (reminder != null) {
			return reminder.getVibrate2(context, preferenceKey, defaultValue);
		}
		return Helper.getBooleanPreferenceValue(context, preferenceKey, defaultValue);
	}

	public ElapsedReminder getElapsedReminder2(Context context) {
		return DataProvider.getElapsedReminder(null, context, elapsedReminderId);
	}

	protected ScheduledReminder(Parcel in) {
		id = in.readByte() == 0x00 ? null : in.readLong();
		reminderId = in.readByte() == 0x00 ? null : in.readLong();
		elapsedReminderId = in.readByte() == 0x00 ? null : in.readLong();
		isQuickReminder = in.readByte() != 0x00;
		assignedRemindAtDateTime = in.readLong();
		nextSnoozeDateTime = in.readLong();
		actualLastAlarmedDateTime = in.readByte() == 0x00 ? null : in.readLong();
		snoozeCount = in.readInt();
		stateValue = in.readInt();
		text = in.readString();
		isAlarm = in.readByte() != 0x00;
		enabled = in.readByte() != 0x00;
		ringtone = in.readString();
		ringtoneFadeInTime = in.readByte() == 0x00 ? null : in.readLong();
		playingTime = in.readByte() == 0x00 ? null : in.readInt();
		automaticSnoozeDuration = in.readByte() == 0x00 ? null : in.readInt();
		automaticSnoozesMaxCount = in.readByte() == 0x00 ? null : in.readInt();
		byte vibrateVal = in.readByte();
		vibrate = vibrateVal == 0x02 ? null : vibrateVal != 0x00;
		vibratePattern = in.readString();
		byte ledVal = in.readByte();
		led = ledVal == 0x02 ? null : ledVal != 0x00;
		ledPattern = in.readString();
		ledColor = in.readByte() == 0x00 ? null : in.readInt();
	}

	@Override
	public int describeContents() {
		return 0;
	}

	@Override
	public void writeToParcel(Parcel dest, int flags) {
		if (id == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(id);
		}
		if (reminderId == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(reminderId);
		}
		if (elapsedReminderId == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(elapsedReminderId);
		}
		dest.writeByte((byte) (isQuickReminder ? 0x01 : 0x00));
		dest.writeLong(assignedRemindAtDateTime);
		dest.writeLong(nextSnoozeDateTime);
		if (actualLastAlarmedDateTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(actualLastAlarmedDateTime);
		}
		dest.writeInt(snoozeCount);
		dest.writeInt(stateValue);
		dest.writeString(text);
		dest.writeByte((byte) (isAlarm ? 0x01 : 0x00));
		dest.writeByte((byte) (enabled ? 0x01 : 0x00));
		dest.writeString(ringtone);
		if (ringtoneFadeInTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(ringtoneFadeInTime);
		}
		if (playingTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(playingTime);
		}
		if (automaticSnoozeDuration == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(automaticSnoozeDuration);
		}
		if (automaticSnoozesMaxCount == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(automaticSnoozesMaxCount);
		}
		if (vibrate == null) {
			dest.writeByte((byte) 0x02);
		} else {
			dest.writeByte((byte) (vibrate ? 0x01 : 0x00));
		}
		dest.writeString(vibratePattern);
		if (led == null) {
			dest.writeByte((byte) 0x02);
		} else {
			dest.writeByte((byte) (led ? 0x01 : 0x00));
		}
		dest.writeString(ledPattern);
		if (ledColor == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(ledColor);
		}
	}

	public static final Parcelable.Creator<ScheduledReminder> CREATOR = new Parcelable.Creator<ScheduledReminder>() {
		@Override
		public ScheduledReminder createFromParcel(Parcel in) {
			return new ScheduledReminder(in);
		}

		@Override
		public ScheduledReminder[] newArray(int size) {
			return new ScheduledReminder[size];
		}
	};
	// KEEP METHODS END
}
