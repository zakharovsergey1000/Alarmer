package biz.advancedcalendar.greendao;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.Property;
import de.greenrobot.dao.internal.DaoConfig;
import de.greenrobot.dao.internal.SqlUtils;
import de.greenrobot.dao.query.Query;
import de.greenrobot.dao.query.QueryBuilder;
import java.util.ArrayList;
import java.util.List;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
/** DAO for table REMINDER. */
public class ReminderDao extends AbstractDao<Reminder, Long> {
	public static final String TABLENAME = "REMINDER";

	/** Properties of entity Reminder.<br/>
	 * Can be used for QueryBuilder and for referencing column names. */
	public static class Properties {
		public final static Property Id = new Property(0, Long.class, "id", true, "_id");
		public final static Property ServerId = new Property(1, Long.class, "serverId",
				false, "SERVER_ID");
		public final static Property TaskId = new Property(2, Long.class, "taskId",
				false, "TASK_ID");
		public final static Property LocalChangeDateTime = new Property(3, long.class,
				"localChangeDateTime", false, "LOCAL_CHANGE_DATE_TIME");
		public final static Property ReminderDateTime = new Property(4, long.class,
				"reminderDateTime", false, "REMINDER_DATE_TIME");
		public final static Property ReminderTimeModeValue = new Property(5, byte.class,
				"reminderTimeModeValue", false, "REMINDER_TIME_MODE");
		public final static Property Text = new Property(6, String.class, "text", false,
				"TEXT");
		public final static Property Enabled = new Property(7, boolean.class, "enabled",
				false, "ENABLED");
		public final static Property IsAlarm = new Property(8, boolean.class, "isAlarm",
				false, "IS_ALARM");
		public final static Property Ringtone = new Property(9, String.class, "ringtone",
				false, "RINGTONE");
		public final static Property PlayingTime = new Property(10, Integer.class,
				"playingTime", false, "PLAYING_TIME");
		public final static Property AutomaticSnoozeDuration = new Property(11,
				Integer.class, "automaticSnoozeDuration", false,
				"AUTOMATIC_SNOOZE_DURATION");
		public final static Property AutomaticSnoozesMaxCount = new Property(12,
				Integer.class, "automaticSnoozesMaxCount", false,
				"AUTOMATIC_SNOOZES_MAX_COUNT");
		public final static Property Vibrate = new Property(13, Boolean.class, "vibrate",
				false, "VIBRATE");
		public final static Property VibratePattern = new Property(14, String.class,
				"vibratePattern", false, "VIBRATE_PATTERN");
		public final static Property Led = new Property(15, Boolean.class, "led", false,
				"LED");
		public final static Property LedPattern = new Property(16, String.class,
				"ledPattern", false, "LED_PATTERN");
		public final static Property LedColor = new Property(17, Integer.class,
				"ledColor", false, "LED_COLOR");
		public final static Property RingtoneFadeInTime = new Property(18, Long.class,
				"ringtoneFadeInTime", false, "RINGTONE_FADE_IN_TIME");
	};

	private DaoSession daoSession;
	private Query<Reminder> task_ReminderListQuery;

	public ReminderDao(DaoConfig config) {
		super(config);
	}

	public ReminderDao(DaoConfig config, DaoSession daoSession) {
		super(config, daoSession);
		this.daoSession = daoSession;
	}

	/** Creates the underlying database table. */
	public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
		String constraint = ifNotExists ? "IF NOT EXISTS " : "";
		db.execSQL("CREATE TABLE " + constraint + "'REMINDER' (" + //
				"'_id' INTEGER PRIMARY KEY ," + // 0: id
				"'SERVER_ID' INTEGER," + // 1: serverId
				"'TASK_ID' INTEGER," + // 2: taskId
				"'LOCAL_CHANGE_DATE_TIME' INTEGER NOT NULL ," + // 3: localChangeDateTime
				"'REMINDER_DATE_TIME' INTEGER NOT NULL ," + // 4: reminderDateTime
				"'REMINDER_TIME_MODE' INTEGER NOT NULL ," + // 5: reminderTimeModeValue
				"'TEXT' TEXT NOT NULL ," + // 6: text
				"'ENABLED' INTEGER NOT NULL ," + // 7: enabled
				"'IS_ALARM' INTEGER NOT NULL ," + // 8: isAlarm
				"'RINGTONE' TEXT," + // 9: ringtone
				"'PLAYING_TIME' INTEGER," + // 10: playingTime
				"'AUTOMATIC_SNOOZE_DURATION' INTEGER," + // 11: automaticSnoozeDuration
				"'AUTOMATIC_SNOOZES_MAX_COUNT' INTEGER," + // 12: automaticSnoozesMaxCount
				"'VIBRATE' INTEGER," + // 13: vibrate
				"'VIBRATE_PATTERN' TEXT," + // 14: vibratePattern
				"'LED' INTEGER," + // 15: led
				"'LED_PATTERN' TEXT," + // 16: ledPattern
				"'LED_COLOR' INTEGER," + // 17: ledColor
				"'RINGTONE_FADE_IN_TIME' INTEGER);"); // 18: ringtoneFadeInTime
	}

	/** Drops the underlying database table. */
	public static void dropTable(SQLiteDatabase db, boolean ifExists) {
		String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'REMINDER'";
		db.execSQL(sql);
	}

	/** @inheritdoc */
	@Override
	protected void bindValues(SQLiteStatement stmt, Reminder entity) {
		stmt.clearBindings();
		Long id = entity.getId();
		if (id != null) {
			stmt.bindLong(1, id);
		}
		Long serverId = entity.getServerId();
		if (serverId != null) {
			stmt.bindLong(2, serverId);
		}
		Long taskId = entity.getTaskId();
		if (taskId != null) {
			stmt.bindLong(3, taskId);
		}
		stmt.bindLong(4, entity.getLocalChangeDateTime());
		stmt.bindLong(5, entity.getReminderDateTime());
		stmt.bindLong(6, entity.getReminderTimeModeValue());
		stmt.bindString(7, entity.getText());
		stmt.bindLong(8, entity.getEnabled() ? 1l : 0l);
		stmt.bindLong(9, entity.getIsAlarm() ? 1l : 0l);
		String ringtone = entity.getRingtone();
		if (ringtone != null) {
			stmt.bindString(10, ringtone);
		}
		Long ringtoneFadeInTime = entity.getRingtoneFadeInTime();
		if (ringtoneFadeInTime != null) {
			stmt.bindLong(19, ringtoneFadeInTime);
		}
		Integer playingTime = entity.getPlayingTime();
		if (playingTime != null) {
			stmt.bindLong(11, playingTime);
		}
		Integer automaticSnoozeDuration = entity.getAutomaticSnoozeDuration();
		if (automaticSnoozeDuration != null) {
			stmt.bindLong(12, automaticSnoozeDuration);
		}
		Integer automaticSnoozesMaxCount = entity.getAutomaticSnoozesMaxCount();
		if (automaticSnoozesMaxCount != null) {
			stmt.bindLong(13, automaticSnoozesMaxCount);
		}
		Boolean vibrate = entity.getVibrate();
		if (vibrate != null) {
			stmt.bindLong(14, vibrate ? 1l : 0l);
		}
		String vibratePattern = entity.getVibratePattern();
		if (vibratePattern != null) {
			stmt.bindString(15, vibratePattern);
		}
		Boolean led = entity.getLed();
		if (led != null) {
			stmt.bindLong(16, led ? 1l : 0l);
		}
		String ledPattern = entity.getLedPattern();
		if (ledPattern != null) {
			stmt.bindString(17, ledPattern);
		}
		Integer ledColor = entity.getLedColor();
		if (ledColor != null) {
			stmt.bindLong(18, ledColor);
		}
	}

	@Override
	protected void attachEntity(Reminder entity) {
		super.attachEntity(entity);
		entity.__setDaoSession(daoSession);
	}

	/** @inheritdoc */
	@Override
	public Long readKey(Cursor cursor, int offset) {
		return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
	}

	/** @inheritdoc */
	@Override
	public Reminder readEntity(Cursor cursor, int offset) {
		Reminder entity = new Reminder( //
				cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
				cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1), // serverId
				cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2), // taskId
				cursor.getLong(offset + 3), // localChangeDateTime
				cursor.getLong(offset + 4), // reminderDateTime
				(byte) cursor.getShort(offset + 5), // reminderTimeModeValue
				cursor.getString(offset + 6), // text
				cursor.getShort(offset + 7) != 0, // enabled
				cursor.getShort(offset + 8) != 0, // isAlarm
				cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9), // ringtone
				cursor.isNull(offset + 18) ? null : cursor.getLong(offset + 18), // ringtoneFadeInTime
				cursor.isNull(offset + 10) ? null : cursor.getInt(offset + 10), // playingTime
				cursor.isNull(offset + 11) ? null : cursor.getInt(offset + 11), // automaticSnoozeDuration
				cursor.isNull(offset + 12) ? null : cursor.getInt(offset + 12), // automaticSnoozesMaxCount
				cursor.isNull(offset + 13) ? null : cursor.getShort(offset + 13) != 0, // vibrate
				cursor.isNull(offset + 14) ? null : cursor.getString(offset + 14), // vibratePattern
				cursor.isNull(offset + 15) ? null : cursor.getShort(offset + 15) != 0, // led
				cursor.isNull(offset + 16) ? null : cursor.getString(offset + 16), // ledPattern
				cursor.isNull(offset + 17) ? null : cursor.getInt(offset + 17) // ledColor
		);
		return entity;
	}

	/** @inheritdoc */
	@Override
	public void readEntity(Cursor cursor, Reminder entity, int offset) {
		entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
		entity.setServerId(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
		entity.setTaskId(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
		entity.setLocalChangeDateTime(cursor.getLong(offset + 3));
		entity.setReminderDateTime(cursor.getLong(offset + 4));
		entity.setReminderTimeModeValue((byte) cursor.getShort(offset + 5));
		entity.setText(cursor.getString(offset + 6));
		entity.setEnabled(cursor.getShort(offset + 7) != 0);
		entity.setIsAlarm(cursor.getShort(offset + 8) != 0);
		entity.setRingtone(cursor.isNull(offset + 9) ? null : cursor
				.getString(offset + 9));
		entity.setRingtoneFadeInTime(cursor.isNull(offset + 18) ? null : cursor
				.getLong(offset + 18));
		entity.setPlayingTime(cursor.isNull(offset + 10) ? null : cursor
				.getInt(offset + 10));
		entity.setAutomaticSnoozeDuration(cursor.isNull(offset + 11) ? null : cursor
				.getInt(offset + 11));
		entity.setAutomaticSnoozesMaxCount(cursor.isNull(offset + 12) ? null : cursor
				.getInt(offset + 12));
		entity.setVibrate(cursor.isNull(offset + 13) ? null : cursor
				.getShort(offset + 13) != 0);
		entity.setVibratePattern(cursor.isNull(offset + 14) ? null : cursor
				.getString(offset + 14));
		entity.setLed(cursor.isNull(offset + 15) ? null
				: cursor.getShort(offset + 15) != 0);
		entity.setLedPattern(cursor.isNull(offset + 16) ? null : cursor
				.getString(offset + 16));
		entity.setLedColor(cursor.isNull(offset + 17) ? null : cursor.getInt(offset + 17));
	}

	/** @inheritdoc */
	@Override
	protected Long updateKeyAfterInsert(Reminder entity, long rowId) {
		entity.setId(rowId);
		return rowId;
	}

	/** @inheritdoc */
	@Override
	public Long getKey(Reminder entity) {
		if (entity != null) {
			return entity.getId();
		} else {
			return null;
		}
	}

	/** @inheritdoc */
	@Override
	protected boolean isEntityUpdateable() {
		return true;
	}

	/** Internal query to resolve the "reminderList" to-many relationship of Task. */
	public List<Reminder> _queryTask_ReminderList(Long taskId) {
		synchronized (this) {
			if (task_ReminderListQuery == null) {
				QueryBuilder<Reminder> queryBuilder = queryBuilder();
				queryBuilder.where(Properties.TaskId.eq(null));
				task_ReminderListQuery = queryBuilder.build();
			}
		}
		Query<Reminder> query = task_ReminderListQuery.forCurrentThread();
		query.setParameter(0, taskId);
		return query.list();
	}

	private String selectDeep;

	protected String getSelectDeep() {
		if (selectDeep == null) {
			StringBuilder builder = new StringBuilder("SELECT ");
			SqlUtils.appendColumns(builder, "T", getAllColumns());
			builder.append(',');
			SqlUtils.appendColumns(builder, "T0", daoSession.getTaskDao().getAllColumns());
			builder.append(" FROM REMINDER T");
			builder.append(" LEFT JOIN TASK T0 ON T.'TASK_ID'=T0.'_id'");
			builder.append(' ');
			selectDeep = builder.toString();
		}
		return selectDeep;
	}

	protected Reminder loadCurrentDeep(Cursor cursor, boolean lock) {
		Reminder entity = loadCurrent(cursor, 0, lock);
		int offset = getAllColumns().length;
		Task task = loadCurrentOther(daoSession.getTaskDao(), cursor, offset);
		entity.setTask(task);
		return entity;
	}

	public Reminder loadDeep(Long key) {
		assertSinglePk();
		if (key == null) {
			return null;
		}
		StringBuilder builder = new StringBuilder(getSelectDeep());
		builder.append("WHERE ");
		SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
		String sql = builder.toString();
		String[] keyArray = new String[] {key.toString()};
		Cursor cursor = db.rawQuery(sql, keyArray);
		try {
			boolean available = cursor.moveToFirst();
			if (!available) {
				return null;
			} else if (!cursor.isLast()) {
				throw new IllegalStateException("Expected unique result, but count was "
						+ cursor.getCount());
			}
			return loadCurrentDeep(cursor, true);
		} finally {
			cursor.close();
		}
	}

	/** Reads all available rows from the given cursor and returns a list of new ImageTO
	 * objects. */
	public List<Reminder> loadAllDeepFromCursor(Cursor cursor) {
		int count = cursor.getCount();
		List<Reminder> list = new ArrayList<Reminder>(count);
		if (cursor.moveToFirst()) {
			if (identityScope != null) {
				identityScope.lock();
				identityScope.reserveRoom(count);
			}
			try {
				do {
					list.add(loadCurrentDeep(cursor, false));
				} while (cursor.moveToNext());
			} finally {
				if (identityScope != null) {
					identityScope.unlock();
				}
			}
		}
		return list;
	}

	protected List<Reminder> loadDeepAllAndCloseCursor(Cursor cursor) {
		try {
			return loadAllDeepFromCursor(cursor);
		} finally {
			cursor.close();
		}
	}

	/** A raw-style query where you can pass any WHERE clause and arguments. */
	public List<Reminder> queryDeep(String where, String... selectionArg) {
		Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
		return loadDeepAllAndCloseCursor(cursor);
	}
}
