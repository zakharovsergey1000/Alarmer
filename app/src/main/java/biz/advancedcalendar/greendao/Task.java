package biz.advancedcalendar.greendao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
// KEEP INCLUDES - put your custom includes here
import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.content.res.Resources;
import android.media.RingtoneManager;
import android.os.Parcel;
import android.os.Parcelable;
import android.widget.HorizontalScrollView;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import biz.advancedcalendar.CommonConstants;
import biz.advancedcalendar.alarmer.R;
import biz.advancedcalendar.fragments.FragmentEditTaskPartMain.UserInterfaceData.ValueMustBe;
import biz.advancedcalendar.fragments.FragmentEditTaskPartMain.UserInterfaceData.WantingItem;
import biz.advancedcalendar.utils.CalendarHelper;
import biz.advancedcalendar.utils.Helper;
import biz.advancedcalendar.views.CalendarViewTaskOccurrence;
import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

// KEEP INCLUDES END
/** Entity mapped to table TASK. */
@SuppressLint("UseSparseArrays")
public class Task implements Parcelable {
	private Long id;
	private Long calendarId;
	private Long parentId;
	private long localCreateDateTime;
	private long localChangeDateTime;
	private Long serverId;
	private Long created;
	private Long lastMod;
	private byte syncStatusValue;
	/** Not-null value. */
	private String name;
	private short priority;
	private Integer color;
	private Long startDateTime;
	private Long endDateTime;
	private Integer requiredLength;
	private Integer actualLength;
	private boolean isCompleted;
	private short percentOfCompletion;
	private Long completedTime;
	private boolean deleted;
	private int sortOrder;
	private String description;
	private String location;
	private short recurrenceIntervalValue;
	private Integer timeUnitsCount;
	private Integer occurrencesMaxCount;
	private Long repetitionEndDateTime;
	private String alarmRingtone;
	private String notificationRingtone;
	private Long ringtoneFadeInTime;
	private Integer playingTime;
	private Integer automaticSnoozeDuration;
	private Integer automaticSnoozesMaxCount;
	private Boolean vibrate;
	private String vibratePattern;
	private Boolean led;
	private String ledPattern;
	private Integer ledColor;
	/** Used to resolve relations */
	private transient DaoSession daoSession;
	/** Used for active entity operations. */
	private transient TaskDao myDao;
	private biz.advancedcalendar.greendao.Calendar calendar;
	private Long calendar__resolvedKey;
	private Task task;
	private Long task__resolvedKey;
	private List<TaskOccurrence> taskOccurrenceList;
	private List<Reminder> reminderList;
	private List<TaskLabel> taskLabelList;
	private List<TaskContact> taskContactList;
	private List<FileTask> fileTaskList;

	// KEEP FIELDS - put your custom fields here
	public enum DateTimeResult {
		NOT_EXISTS(0), INFINITY(1), EXACT(2);
		private int value;

		private DateTimeResult(int value) {
			this.value = value;
		}

		public int getValue() {
			return value;
		}

		public static DateTimeResult fromInt(int x) {
			switch (x) {
			case 0:
				return NOT_EXISTS;
			case 1:
				return INFINITY;
			case 2:
				return EXACT;
			default:
				return null;
			}
		}
	}

	public enum InformationUnitSelector {
		ANY_STRING((byte) 18, R.string.information_unit_description_text_any_string), TASK_NAME(
				(byte) 19, R.string.information_unit_description_text_task_name), CURRENT_SCHEDULED_START_DATE_TIME(
				(byte) 20,
				R.string.information_unit_description_text_current_scheduled_start_date_time), CURRENT_SCHEDULED_START_TIME(
				(byte) 21,
				R.string.information_unit_description_text_current_scheduled_start_time), DURATION_OF_THE_TASK(
				(byte) 22,
				R.string.information_unit_description_text_duration_of_the_task), LOCATION(
				(byte) 23, R.string.information_unit_description_text_location), CURRENT_SCHEDULED_START_YEAR(
				(byte) 24,
				R.string.information_unit_description_text_current_scheduled_start_year), CURRENT_SCHEDULED_START_MONTH(
				(byte) 25,
				R.string.information_unit_description_text_current_scheduled_start_month), CURRENT_SCHEDULED_START_DATE_OF_MONTH(
				(byte) 26,
				R.string.information_unit_description_text_current_scheduled_start_date_of_month), CURRENT_SCHEDULED_START_WEEK_DAY(
				(byte) 27,
				R.string.information_unit_description_text_current_scheduled_start_week_day), CURRENT_SCHEDULED_END_DATE_TIME(
				(byte) 28,
				R.string.information_unit_description_text_current_scheduled_end_date_time), CURRENT_SCHEDULED_END_TIME(
				(byte) 29,
				R.string.information_unit_description_text_current_scheduled_end_time), CURRENT_SCHEDULED_END_YEAR(
				(byte) 30,
				R.string.information_unit_description_text_current_scheduled_end_year), CURRENT_SCHEDULED_END_MONTH(
				(byte) 31,
				R.string.information_unit_description_text_current_scheduled_end_month), CURRENT_SCHEDULED_END_DATE_OF_MONTH(
				(byte) 32,
				R.string.information_unit_description_text_current_scheduled_end_date_of_month), CURRENT_SCHEDULED_END_WEEK_DAY(
				(byte) 33,
				R.string.information_unit_description_text_current_scheduled_end_week_day), NEXT_SCHEDULED_START_DATE_TIME(
				(byte) 34,
				R.string.information_unit_description_text_next_scheduled_start_date_time), NEXT_SCHEDULED_START_TIME(
				(byte) 35,
				R.string.information_unit_description_text_next_scheduled_start_time), NEXT_SCHEDULED_START_YEAR(
				(byte) 36,
				R.string.information_unit_description_text_next_scheduled_start_year), NEXT_SCHEDULED_START_MONTH(
				(byte) 37,
				R.string.information_unit_description_text_next_scheduled_start_month), NEXT_SCHEDULED_START_DATE_OF_MONTH(
				(byte) 38,
				R.string.information_unit_description_text_next_scheduled_start_date_of_month), NEXT_SCHEDULED_START_WEEK_DAY(
				(byte) 39,
				R.string.information_unit_description_text_next_scheduled_start_week_day), NEXT_SCHEDULED_END_DATE_TIME(
				(byte) 40,
				R.string.information_unit_description_text_next_scheduled_end_date_time), NEXT_SCHEDULED_END_TIME(
				(byte) 41,
				R.string.information_unit_description_text_next_scheduled_end_time), NEXT_SCHEDULED_END_YEAR(
				(byte) 42,
				R.string.information_unit_description_text_next_scheduled_end_year), NEXT_SCHEDULED_END_MONTH(
				(byte) 43,
				R.string.information_unit_description_text_next_scheduled_end_month), NEXT_SCHEDULED_END_DATE_OF_MONTH(
				(byte) 44,
				R.string.information_unit_description_text_next_scheduled_end_date_of_month), NEXT_SCHEDULED_END_WEEK_DAY(
				(byte) 45,
				R.string.information_unit_description_text_next_scheduled_end_week_day), FIRST_SCHEDULED_START_DATE_TIME(
				(byte) 46,
				R.string.information_unit_description_text_first_scheduled_start_date_time), FIRST_SCHEDULED_START_TIME(
				(byte) 47,
				R.string.information_unit_description_text_first_scheduled_start_time), FIRST_SCHEDULED_START_YEAR(
				(byte) 48,
				R.string.information_unit_description_text_first_scheduled_start_year), FIRST_SCHEDULED_START_MONTH(
				(byte) 49,
				R.string.information_unit_description_text_first_scheduled_start_month), FIRST_SCHEDULED_START_DATE_OF_MONTH(
				(byte) 50,
				R.string.information_unit_description_text_first_scheduled_start_date_of_month), FIRST_SCHEDULED_START_WEEK_DAY(
				(byte) 51,
				R.string.information_unit_description_text_first_scheduled_start_week_day), FIRST_SCHEDULED_END_DATE_TIME(
				(byte) 52,
				R.string.information_unit_description_text_first_scheduled_end_date_time), FIRST_SCHEDULED_END_TIME(
				(byte) 53,
				R.string.information_unit_description_text_first_scheduled_end_time), FIRST_SCHEDULED_END_YEAR(
				(byte) 54,
				R.string.information_unit_description_text_first_scheduled_end_year), FIRST_SCHEDULED_END_MONTH(
				(byte) 55,
				R.string.information_unit_description_text_first_scheduled_end_month), FIRST_SCHEDULED_END_DATE_OF_MONTH(
				(byte) 56,
				R.string.information_unit_description_text_first_scheduled_end_date_of_month), FIRST_SCHEDULED_END_WEEK_DAY(
				(byte) 57,
				R.string.information_unit_description_text_first_scheduled_end_week_day), INFORMATION_ABOUT_REPETITION(
				(byte) 58,
				R.string.information_unit_description_text_information_about_repetition), INFORMATION_ABOUT_REMINDERS(
				(byte) 59,
				R.string.information_unit_description_text_information_about_reminders);
		private byte value;
		private int textId;

		private InformationUnitSelector(byte value, int textId) {
			this.value = value;
			this.textId = textId;
		}

		public byte getValue() {
			return value;
		}

		public int getTextId() {
			return textId;
		}

		public static List<InformationUnitSelector> getList() {
			return InformationUnitSelector.list;
		}

		private static List<InformationUnitSelector> list = new ArrayList<InformationUnitSelector>();
		private static Map<Byte, InformationUnitSelector> map = new HashMap<Byte, InformationUnitSelector>();
		private static Map<String, InformationUnitSelector> stringToObjectMap = new HashMap<String, InformationUnitSelector>();
		static {
			for (InformationUnitSelector informationUnitSelector : InformationUnitSelector
					.values()) {
				InformationUnitSelector.map.put(informationUnitSelector.value,
						informationUnitSelector);
				InformationUnitSelector.stringToObjectMap.put(
						informationUnitSelector.name(), informationUnitSelector);
				InformationUnitSelector.list.add(informationUnitSelector);
			}
		}

		public static InformationUnitSelector fromInt(byte value) {
			InformationUnitSelector informationUnitSelector = InformationUnitSelector.map
					.get(value);
			return informationUnitSelector;
		}

		public static InformationUnitSelector fromString(String name) {
			InformationUnitSelector informationUnitSelector = InformationUnitSelector.stringToObjectMap
					.get(name);
			return informationUnitSelector;
		}
	}

	public enum PRIORITY {
		LOW((short) 1), MEDIUM((short) 0), HIGH((short) 2);
		private short value;

		private PRIORITY(short value) {
			this.value = value;
		}

		/** @return the value */
		public short getValue() {
			return value;
		}

		public static PRIORITY fromInt(int x) {
			switch (x) {
			case 0:
			default:
				return MEDIUM;
			case 1:
				return LOW;
			case 2:
				return HIGH;
			}
		}
	}

	public enum TimeUnit {
		ONE_TIME((short) CommonConstants.TIME_UNIT_ONE_TIME), MINUTE(
				(short) CommonConstants.TIME_UNIT_MINUTE), HOUR(
				(short) CommonConstants.TIME_UNIT_HOUR), DAY(
				(short) CommonConstants.TIME_UNIT_DAY), WEEK(
				(short) CommonConstants.TIME_UNIT_WEEK), MONTH(
				(short) CommonConstants.TIME_UNIT_MONTH), YEAR(
				(short) CommonConstants.TIME_UNIT_YEAR);
		private short value;

		private TimeUnit(short value) {
			this.value = value;
		}

		public short getShortValue() {
			return value;
		}

		public int getIntegerValue() {
			return value;
		}

		public static TimeUnit fromRecurrenceInterval (
				RecurrenceInterval recurrenceInterval) {
			switch (recurrenceInterval) {
			case ONE_TIME:
			default:
				return ONE_TIME;
			case DAYS:
				return DAY;
			case WEEKS:
				return WEEK;
			case MONTHS_ON_DATE:
			case MONTHS_ON_NTH_WEEK_DAY:
				return MONTH;
			case YEARS:
				return YEAR;
			case MINUTES:
				return MINUTE;
			case HOURS:
				return HOUR;
			}
		}

		private static Map<Short, TimeUnit> map = new HashMap<Short, TimeUnit>();
//		private static Map<RecurrenceInterval, TimeUnit> recurrenceIntervalToTimeUnitMap = new HashMap<RecurrenceInterval, TimeUnit>();
		static {
			for (TimeUnit timeUnit : TimeUnit.values()) {
				TimeUnit.map.put(timeUnit.value, timeUnit);
			}
//			for (RecurrenceInterval recurrenceInterval : RecurrenceInterval.values()) {
//				TimeUnit timeUnit = TimeUnit
//						.fromRecurrenceIntervalInternal(recurrenceInterval);
//				TimeUnit.recurrenceIntervalToTimeUnitMap
//						.put(recurrenceInterval, timeUnit);
//			}
		}

		public static TimeUnit fromInt(short value) {
			TimeUnit timeUnit = TimeUnit.map.get(value);
			return timeUnit;
		}

//		public static TimeUnit fromRecurrenceInterval(RecurrenceInterval value) {
//			TimeUnit timeUnit = TimeUnit.recurrenceIntervalToTimeUnitMap.get(value);
//			return timeUnit;
//		}
	}

	public enum BusinessHoursTaskDisplayingPolicy {
		DISPLAY_SEPARATED((byte) 1), DISPLAY_AS_USUAL((byte) 2), DO_NOT_DISPLAY((byte) 3), ;
		private byte value;

		private BusinessHoursTaskDisplayingPolicy(byte value) {
			this.value = value;
		}

		public byte getValue() {
			return value;
		}

		private static Map<Byte, BusinessHoursTaskDisplayingPolicy> map = new HashMap<Byte, BusinessHoursTaskDisplayingPolicy>();
		private static Map<String, BusinessHoursTaskDisplayingPolicy> stringToObjectMap = new HashMap<String, BusinessHoursTaskDisplayingPolicy>();
		static {
			for (BusinessHoursTaskDisplayingPolicy businessHoursTaskDisplayingPolicy : BusinessHoursTaskDisplayingPolicy
					.values()) {
				BusinessHoursTaskDisplayingPolicy.map.put(
						businessHoursTaskDisplayingPolicy.value,
						businessHoursTaskDisplayingPolicy);
				BusinessHoursTaskDisplayingPolicy.stringToObjectMap.put(
						businessHoursTaskDisplayingPolicy.name(),
						businessHoursTaskDisplayingPolicy);
			}
		}

		public static BusinessHoursTaskDisplayingPolicy fromInt(byte value) {
			BusinessHoursTaskDisplayingPolicy businessHoursTaskDisplayingPolicy = BusinessHoursTaskDisplayingPolicy.map
					.get(value);
			return businessHoursTaskDisplayingPolicy;
		}

		public static BusinessHoursTaskDisplayingPolicy fromString(String name) {
			BusinessHoursTaskDisplayingPolicy businessHoursTaskDisplayingPolicy = BusinessHoursTaskDisplayingPolicy.stringToObjectMap
					.get(name);
			return businessHoursTaskDisplayingPolicy;
		}
	}

	public enum HoursRulerDisplayingPolicy {
		DISPLAY_ONLY_ONE_HOURS_RULER((byte) 1), DISPLAY_SEPARATE_HOURS_RULER_FOR_EACH_DAY(
				(byte) 2), ;
		private byte value;

		private HoursRulerDisplayingPolicy(byte value) {
			this.value = value;
		}

		public byte getValue() {
			return value;
		}

		private static Map<Byte, HoursRulerDisplayingPolicy> map = new HashMap<Byte, HoursRulerDisplayingPolicy>();
		private static Map<String, HoursRulerDisplayingPolicy> stringToObjectMap = new HashMap<String, HoursRulerDisplayingPolicy>();
		static {
			for (HoursRulerDisplayingPolicy hoursRulerDisplayingPolicy : HoursRulerDisplayingPolicy
					.values()) {
				HoursRulerDisplayingPolicy.map.put(hoursRulerDisplayingPolicy.value,
						hoursRulerDisplayingPolicy);
				HoursRulerDisplayingPolicy.stringToObjectMap.put(
						hoursRulerDisplayingPolicy.name(), hoursRulerDisplayingPolicy);
			}
		}

		public static HoursRulerDisplayingPolicy fromInt(byte value) {
			HoursRulerDisplayingPolicy hoursRulerDisplayingPolicy = HoursRulerDisplayingPolicy.map
					.get(value);
			return hoursRulerDisplayingPolicy;
		}

		public static HoursRulerDisplayingPolicy fromString(String name) {
			HoursRulerDisplayingPolicy hoursRulerDisplayingPolicy = HoursRulerDisplayingPolicy.stringToObjectMap
					.get(name);
			return hoursRulerDisplayingPolicy;
		}
	}

	public enum TaskEditMode {
		ADD((byte) 1), QUICK((byte) 2), EDIT((byte) 3), ;
		private byte value;

		private TaskEditMode(byte value) {
			this.value = value;
		}

		public byte getValue() {
			return value;
		}

		private static Map<Byte, TaskEditMode> map = new HashMap<Byte, TaskEditMode>();
		private static Map<String, TaskEditMode> stringToObjectMap = new HashMap<String, TaskEditMode>();
		static {
			for (TaskEditMode taskEditMode : TaskEditMode.values()) {
				TaskEditMode.map.put(taskEditMode.value, taskEditMode);
				TaskEditMode.stringToObjectMap.put(taskEditMode.name(), taskEditMode);
			}
		}

		public static TaskEditMode fromInt(byte value) {
			TaskEditMode taskEditMode = TaskEditMode.map.get(value);
			return taskEditMode;
		}

		public static TaskEditMode fromString(String name) {
			TaskEditMode taskEditMode = TaskEditMode.stringToObjectMap.get(name);
			return taskEditMode;
		}
	}

	public enum OnTaskSelectAction {
		OPEN_TASK_IN_EDIT_MODE(
				(short) CommonConstants.ON_TASK_SELECT_ACTION_OPEN_TASK_IN_EDIT_MODE), OPEN_TASK_IN_VIEW_MODE(
				(short) CommonConstants.ON_TASK_SELECT_ACTION_OPEN_TASK_IN_VIEW_MODE);
		private short value;

		private OnTaskSelectAction(short value) {
			this.value = value;
		}

		/** @return the value */
		public short getValue() {
			return value;
		}

		private static Map<Short, OnTaskSelectAction> map = new HashMap<Short, OnTaskSelectAction>();
		static {
			for (OnTaskSelectAction datePickerDate : OnTaskSelectAction.values()) {
				OnTaskSelectAction.map.put(datePickerDate.value, datePickerDate);
			}
		}

		public static OnTaskSelectAction fromInt(short calendarSelectedDate) {
			OnTaskSelectAction datePickerDate = OnTaskSelectAction.map
					.get(calendarSelectedDate);
			return datePickerDate;
		}
	}

	public enum StartTimeRequiredAction {
		LOAD_FROM_SETTINGS(
				(short) CommonConstants.START_TIME_REQUIRED_ACTION_LOAD_FROM_SETTINGS), SET_TO_CURRENT_TIME(
				(short) CommonConstants.START_TIME_REQUIRED_ACTION_SET_TO_CURRENT_TIME), DO_NOT_AUTOMATICALLY_SET(
				(short) CommonConstants.START_TIME_REQUIRED_ACTION_DO_NOT_AUTOMATICALLY_SET), ;
		private short value;

		private StartTimeRequiredAction(short value) {
			this.value = value;
		}

		/** @return the value */
		public short getValue() {
			return value;
		}

		private static Map<Short, StartTimeRequiredAction> map = new HashMap<Short, StartTimeRequiredAction>();
		static {
			for (StartTimeRequiredAction datePickerDate : StartTimeRequiredAction
					.values()) {
				StartTimeRequiredAction.map.put(datePickerDate.value, datePickerDate);
			}
		}

		public static StartTimeRequiredAction fromInt(short calendarSelectedDate) {
			StartTimeRequiredAction datePickerDate = StartTimeRequiredAction.map
					.get(calendarSelectedDate);
			return datePickerDate;
		}
	}

	public enum RecurrenceInterval {
		ONE_TIME((short) CommonConstants.RECURRENCE_INTERVAL_ONE_TIME,
				R.string.toast_text_time_units_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_time_units_count_must_be_less_than_or_equal_to,
				R.string.toast_text_time_units_count_must_be_within_bounds,
				R.string.text_minute, R.string.text_minutes,
				R.integer.time_units_count_default_value,
				R.integer.time_units_count_min_value,
				R.integer.time_units_count_max_value,
				R.string.preference_key_time_units_count,
				R.id.scrollview_occurrences_picker_minutely_recurrent,
				R.id.linearlayout_occurrences_picker, new ArrayList<TaskOccurrence>(),
				WantingItem.TIME_UNITS_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.TIME_UNITS_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.TIME_UNITS_COUNT_TO_BE_WITHIN_BOUNDS, WantingItem.OCCURRENCES), MINUTES(
				(short) CommonConstants.RECURRENCE_INTERVAL_MINUTES,
				R.string.toast_text_minutes_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_minutes_count_must_be_less_than_or_equal_to,
				R.string.toast_text_minutes_count_must_be_within_bounds,
				R.string.text_minute, R.string.text_minutes,
				R.integer.time_units_count_minutely_recurrent_default_value,
				R.integer.time_units_count_minutely_recurrent_min_value,
				R.integer.time_units_count_minutely_recurrent_max_value,
				R.string.preference_key_time_units_count_minutely_recurrent,
				R.id.scrollview_occurrences_picker_minutely_recurrent,
				R.id.linearlayout_occurrences_picker, new ArrayList<TaskOccurrence>(),
				WantingItem.MINUTES_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.MINUTES_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.MINUTES_COUNT_TO_BE_WITHIN_BOUNDS,
				WantingItem.OCCURRENCES_OF_MINUTELY_RECURRENT_TASK), HOURS(
				(short) CommonConstants.RECURRENCE_INTERVAL_HOURS,
				R.string.toast_text_hours_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_hours_count_must_be_less_than_or_equal_to,
				R.string.toast_text_hours_count_must_be_within_bounds,
				R.string.text_hour, R.string.text_hours,
				R.integer.time_units_count_hourly_recurrent_default_value,
				R.integer.time_units_count_hourly_recurrent_min_value,
				R.integer.time_units_count_hourly_recurrent_max_value,
				R.string.preference_key_time_units_count_hourly_recurrent,
				R.id.scrollview_occurrences_picker_hourly_recurrent,
				R.id.linearlayout_occurrences_picker, new ArrayList<TaskOccurrence>(),
				WantingItem.HOURS_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.HOURS_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.HOURS_COUNT_TO_BE_WITHIN_BOUNDS,
				WantingItem.OCCURRENCES_OF_HOURLY_RECURRENT_TASK), DAYS(
				(short) CommonConstants.RECURRENCE_INTERVAL_DAYS,
				R.string.toast_text_days_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_days_count_must_be_less_than_or_equal_to,
				R.string.toast_text_days_count_must_be_within_bounds, R.string.text_day,
				R.string.text_days,
				R.integer.time_units_count_daily_recurrent_default_value,
				R.integer.time_units_count_daily_recurrent_min_value,
				R.integer.time_units_count_daily_recurrent_max_value,
				R.string.preference_key_time_units_count_daily_recurrent,
				R.id.scrollview_occurrences_picker_daily_recurrent,
				R.id.linearlayout_occurrences_picker, new ArrayList<TaskOccurrence>(),
				WantingItem.DAYS_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.DAYS_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.DAYS_COUNT_TO_BE_WITHIN_BOUNDS,
				WantingItem.OCCURRENCES_OF_DAILY_RECURRENT_TASK), WEEKS(
				(short) CommonConstants.RECURRENCE_INTERVAL_WEEKS,
				R.string.toast_text_weeks_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_weeks_count_must_be_less_than_or_equal_to,
				R.string.toast_text_weeks_count_must_be_within_bounds,
				R.string.text_week, R.string.text_weeks,
				R.integer.time_units_count_weekly_recurrent_default_value,
				R.integer.time_units_count_weekly_recurrent_min_value,
				R.integer.time_units_count_weekly_recurrent_max_value,
				R.string.preference_key_time_units_count_weekly_recurrent,
				R.id.scrollview_week_days_picker, R.id.linearlayout_occurrences_picker,
				new ArrayList<TaskOccurrence>(),
				WantingItem.WEEKS_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.WEEKS_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.WEEKS_COUNT_TO_BE_WITHIN_BOUNDS,
				WantingItem.OCCURRENCES_OF_WEEKLY_RECURRENT_TASK), MONTHS_ON_DATE(
				(short) CommonConstants.RECURRENCE_INTERVAL_MONTHS_ON_DATE,
				R.string.toast_text_months_on_date_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_months_on_date_count_must_be_less_than_or_equal_to,
				R.string.toast_text_months_on_date_count_must_be_within_bounds,
				R.string.text_month, R.string.text_months,
				R.integer.time_units_count_monthly_recurrent_on_date_default_value,
				R.integer.time_units_count_monthly_recurrent_on_date_min_value,
				R.integer.time_units_count_monthly_recurrent_on_date_max_value,
				R.string.preference_key_time_units_count_monthly_recurrent_on_date,
				R.id.scrollview_occurrences_picker_monthly_recurrent_on_date,
				R.id.linearlayout_occurrences_picker, new ArrayList<TaskOccurrence>(),
				WantingItem.MONTHS_ON_DATE_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.MONTHS_ON_DATE_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.MONTHS_ON_DATE_COUNT_TO_BE_WITHIN_BOUNDS,
				WantingItem.OCCURRENCES_OF_TASK_MONTHLY_RECURRENT_ON_DATE), MONTHS_ON_NTH_WEEK_DAY(
				(short) CommonConstants.RECURRENCE_INTERVAL_MONTHS_ON_NTH_WEEK_DAY,
				R.string.toast_text_months_on_nth_week_day_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_months_on_nth_week_day_count_must_be_less_than_or_equal_to,
				R.string.toast_text_months_on_nth_week_day_count_must_be_within_bounds,
				R.string.text_month,
				R.string.text_months,
				R.integer.time_units_count_monthly_recurrent_on_nth_week_day_default_value,
				R.integer.time_units_count_monthly_recurrent_on_nth_week_day_min_value,
				R.integer.time_units_count_monthly_recurrent_on_nth_week_day_max_value,
				R.string.preference_key_time_units_count_monthly_recurrent_on_nth_week_day,
				R.id.linearlayout_occurrences_picker_monthly_recurrent_on_nth_week_day,
				R.id.linearlayout_occurrences_picker, new ArrayList<TaskOccurrence>(),
				WantingItem.MONTHS_ON_NTH_WEEK_DAY_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.MONTHS_ON_NTH_WEEK_DAY_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.MONTHS_ON_NTH_WEEK_DAY_COUNT_TO_BE_WITHIN_BOUNDS,
				WantingItem.OCCURRENCES_OF_TASK_MONTHLY_RECURRENT_ON_NTH_WEEK_DAY), YEARS(
				(short) CommonConstants.RECURRENCE_INTERVAL_YEARS,
				R.string.toast_text_years_count_must_be_greater_than_or_equal_to,
				R.string.toast_text_years_count_must_be_less_than_or_equal_to,
				R.string.toast_text_years_count_must_be_within_bounds,
				R.string.text_year, R.string.text_years,
				R.integer.time_units_count_yearly_recurrent_default_value,
				R.integer.time_units_count_yearly_recurrent_min_value,
				R.integer.time_units_count_yearly_recurrent_max_value,
				R.string.preference_key_time_units_count_yearly_recurrent,
				R.id.linearlayout_occurrences_picker_yearly_recurrent,
				R.id.linearlayout_occurrences_picker, new ArrayList<TaskOccurrence>(),
				WantingItem.YEARS_COUNT_TO_BE_GREATER_THAN_OR_EQUAL_TO,
				WantingItem.YEARS_COUNT_TO_BE_LESS_THAN_OR_EQUAL_TO,
				WantingItem.YEARS_COUNT_TO_BE_WITHIN_BOUNDS,
				WantingItem.OCCURRENCES_OF_YEARLY_RECURRENT_TASK);
		private short value;
		private int toastTextIdTimeUnitsCountMustBeGreaterThanOrEqualTo;
		private int toastTextIdTimeUnitsCountMustBeLessThanOrEqualTo;
		private int toastTextIdTimeUnitsCountMustBeWithinBounds;
		private int textviewIdTimeUnitTextSingular;
		private int textviewIdTimeUnitTextPlural;
		private int timeUnitsCountDefaultValueId;
		private int timeUnitsCountMinValueId;
		private int timeUnitsCountMaxValueId;
		private int preferenceKeyIdTimeUnitsCount;
		private int scrollviewIdOccurrencesPicker;
		private int linearlayoutIdOccurrencesPicker;
		private int timeUnitsCountDefaultValue;
		private int timeUnitsCountMinValue;
		private int timeUnitsCountMaxValue;
		private int timeUnitsCount;
		private int checkBoxCount;
		private CharSequence textTimeUnitsCount;
		private ValueMustBe timeUnitsCountMustBe;
		private List<TaskOccurrence> taskOccurrences;
		private WantingItem wantingItemTimeUnitsCountToBeGreaterThanOrEqualTo;
		private WantingItem wantingItemTimeUnitsCountToBeLessThanOrEqualTo;
		private WantingItem wantingItemTimeUnitsCountToBeWithinBounds;
		private WantingItem wantingItemOccurrences;
		private HorizontalScrollView scrollviewOccurrencesPicker;
		private LinearLayout linearlayoutOccurrencesPicker;
		private LinearLayout occurrencesPicker;

		public static void initializeValueBounds(Context context) {
			Resources resources = context.getResources();
			for (RecurrenceInterval recurrenceInterval : RecurrenceInterval.values()) {
				recurrenceInterval.taskOccurrences.clear();
				recurrenceInterval.timeUnitsCountDefaultValue = resources
						.getInteger(recurrenceInterval.timeUnitsCountDefaultValueId);
				recurrenceInterval.timeUnitsCountMinValue = resources
						.getInteger(recurrenceInterval.timeUnitsCountMinValueId);
				recurrenceInterval.timeUnitsCountMaxValue = resources
						.getInteger(recurrenceInterval.timeUnitsCountMaxValueId);
				recurrenceInterval.timeUnitsCount = Helper
						.getIntegerFromStringPreferenceValue(context,
								recurrenceInterval.preferenceKeyIdTimeUnitsCount, null,
								recurrenceInterval.timeUnitsCountDefaultValue,
								recurrenceInterval.timeUnitsCountMinValue,
								recurrenceInterval.timeUnitsCountMaxValue);
				recurrenceInterval.textTimeUnitsCount = String
						.valueOf(recurrenceInterval.timeUnitsCount);
				recurrenceInterval.timeUnitsCountMustBe = null;
			}
		}

		public static void initializeOccurrencesPicker(Activity activity) {
			for (RecurrenceInterval recurrenceInterval : RecurrenceInterval.values()) {
				if (recurrenceInterval == RecurrenceInterval.MINUTES
						|| recurrenceInterval == RecurrenceInterval.HOURS
						|| recurrenceInterval == RecurrenceInterval.DAYS
						|| recurrenceInterval == RecurrenceInterval.WEEKS
						|| recurrenceInterval == RecurrenceInterval.MONTHS_ON_DATE) {
					recurrenceInterval.scrollviewOccurrencesPicker = (HorizontalScrollView) activity
							.findViewById(recurrenceInterval.scrollviewIdOccurrencesPicker);
					recurrenceInterval.occurrencesPicker = (LinearLayout) recurrenceInterval.scrollviewOccurrencesPicker
							.findViewById(recurrenceInterval.linearlayoutIdOccurrencesPicker);
				} else if (recurrenceInterval == RecurrenceInterval.MONTHS_ON_NTH_WEEK_DAY
						|| recurrenceInterval == RecurrenceInterval.YEARS) {
					recurrenceInterval.linearlayoutOccurrencesPicker = (LinearLayout) activity
							.findViewById(recurrenceInterval.scrollviewIdOccurrencesPicker);
					recurrenceInterval.occurrencesPicker = (LinearLayout) recurrenceInterval.linearlayoutOccurrencesPicker
							.findViewById(recurrenceInterval.linearlayoutIdOccurrencesPicker);
				}
			}
		}

		private RecurrenceInterval(short value,
				int toastTextIdTimeUnitsCountMustBeGreaterThanOrEqualTo,
				int toastTextIdTimeUnitsCountMustBeLessThanOrEqualTo,
				int toastTextIdTimeUnitsCountMustBeWithinBounds,
				int textviewIdTimeUnitTextSingular, int textviewIdTimeUnitTextPlural,
				int timeUnitsCountDefaultValueId, int timeUnitsCountMinValueId,
				int timeUnitsCountMaxValueId, int preferenceKeyIdTimeUnitsCount,
				int scrollviewIdOccurrencesPicker, int linearlayoutIdOccurrencesPicker,
				List<TaskOccurrence> taskOccurrences,
				WantingItem wantingItemTimeUnitsCountToBeGreaterThanOrEqualTo,
				WantingItem wantingItemTimeUnitsCountToBeLessThanOrEqualTo,
				WantingItem wantingItemTimeUnitsCountToBeWithinBounds,
				WantingItem wantingItemOccurrences) {
			this.value = value;
			this.toastTextIdTimeUnitsCountMustBeGreaterThanOrEqualTo = toastTextIdTimeUnitsCountMustBeGreaterThanOrEqualTo;
			this.toastTextIdTimeUnitsCountMustBeLessThanOrEqualTo = toastTextIdTimeUnitsCountMustBeLessThanOrEqualTo;
			this.toastTextIdTimeUnitsCountMustBeWithinBounds = toastTextIdTimeUnitsCountMustBeWithinBounds;
			this.textviewIdTimeUnitTextSingular = textviewIdTimeUnitTextSingular;
			this.textviewIdTimeUnitTextPlural = textviewIdTimeUnitTextPlural;
			this.timeUnitsCountDefaultValueId = timeUnitsCountDefaultValueId;
			this.timeUnitsCountMinValueId = timeUnitsCountMinValueId;
			this.timeUnitsCountMaxValueId = timeUnitsCountMaxValueId;
			this.preferenceKeyIdTimeUnitsCount = preferenceKeyIdTimeUnitsCount;
			this.scrollviewIdOccurrencesPicker = scrollviewIdOccurrencesPicker;
			this.linearlayoutIdOccurrencesPicker = linearlayoutIdOccurrencesPicker;
			this.taskOccurrences = taskOccurrences;
			this.wantingItemTimeUnitsCountToBeGreaterThanOrEqualTo = wantingItemTimeUnitsCountToBeGreaterThanOrEqualTo;
			this.wantingItemTimeUnitsCountToBeLessThanOrEqualTo = wantingItemTimeUnitsCountToBeLessThanOrEqualTo;
			this.wantingItemTimeUnitsCountToBeWithinBounds = wantingItemTimeUnitsCountToBeWithinBounds;
			this.wantingItemOccurrences = wantingItemOccurrences;
		}

		public short getValue() {
			return value;
		}

		public int getToastTextIdTimeUnitsCountMustBeGreaterThanOrEqualTo() {
			return toastTextIdTimeUnitsCountMustBeGreaterThanOrEqualTo;
		}

		public int getToastTextIdTimeUnitsCountMustBeLessThanOrEqualTo() {
			return toastTextIdTimeUnitsCountMustBeLessThanOrEqualTo;
		}

		public int getToastTextIdTimeUnitsCountMustBeWithinBounds() {
			return toastTextIdTimeUnitsCountMustBeWithinBounds;
		}

		public int getTextviewIdTimeUnitTextSingular() {
			return textviewIdTimeUnitTextSingular;
		}

		public int getTextviewIdTimeUnitTextPlural() {
			return textviewIdTimeUnitTextPlural;
		}

		public int getTimeUnitsCountDefaultValue() {
			return timeUnitsCountDefaultValue;
		}

		public int getTimeUnitsCountMinValue() {
			return timeUnitsCountMinValue;
		}

		public int getTimeUnitsCountMaxValue() {
			return timeUnitsCountMaxValue;
		}

		public int getTimeUnitsCount() {
			return timeUnitsCount;
		}

		public void setTimeUnitsCount(int timeUnitsCount) {
			this.timeUnitsCount = timeUnitsCount;
		}

		public int getCheckBoxCount() {
			return checkBoxCount;
		}

		public void setCheckBoxCount(int checkBoxCount) {
			this.checkBoxCount = checkBoxCount;
		}

		public CharSequence getTextTimeUnitsCount() {
			return textTimeUnitsCount;
		}

		public void setTextTimeUnitsCount(CharSequence textTimeUnitsCount) {
			this.textTimeUnitsCount = textTimeUnitsCount;
		}

		public ValueMustBe getTimeUnitsCountMustBe() {
			return timeUnitsCountMustBe;
		}

		public void setTimeUnitsCountMustBe(ValueMustBe timeUnitsCountMustBe) {
			this.timeUnitsCountMustBe = timeUnitsCountMustBe;
		}

		public List<TaskOccurrence> getTaskOccurrences() {
			return taskOccurrences;
		}

		public void setTaskOccurrences(List<TaskOccurrence> taskOccurrences) {
			this.taskOccurrences = taskOccurrences;
		}

		public WantingItem getWantingItemTimeUnitsCountToBeGreaterThanOrEqualTo() {
			return wantingItemTimeUnitsCountToBeGreaterThanOrEqualTo;
		}

		public WantingItem getWantingItemTimeUnitsCountToBeLessThanOrEqualTo() {
			return wantingItemTimeUnitsCountToBeLessThanOrEqualTo;
		}

		public WantingItem getWantingItemTimeUnitsCountToBeWithinBounds() {
			return wantingItemTimeUnitsCountToBeWithinBounds;
		}

		public WantingItem getWantingItemOccurrences() {
			return wantingItemOccurrences;
		}

		public HorizontalScrollView getScrollviewOccurrencesPicker() {
			return scrollviewOccurrencesPicker;
		}

		public LinearLayout getOccurrencesPicker() {
			return occurrencesPicker;
		}

		private static Map<Short, RecurrenceInterval> map = new HashMap<Short, RecurrenceInterval>();
		// private static Map<RecurrenceInterval, ValueBounds<Integer>>
		// recurrenceIntervalToValueBoundsMap = new HashMap<RecurrenceInterval,
		// ValueBounds<Integer>>();
		private static Map<String, RecurrenceInterval> stringToObjectMap = new HashMap<String, RecurrenceInterval>();
		private static Map<Short, RecurrenceInterval> timeUnitToRecurrenceIntervalMap = new HashMap<Short, RecurrenceInterval>();
		static {
			for (RecurrenceInterval recurrenceInterval : RecurrenceInterval.values()) {
				RecurrenceInterval.map.put(recurrenceInterval.value, recurrenceInterval);
				RecurrenceInterval.stringToObjectMap.put(recurrenceInterval.name(),
						recurrenceInterval);
			}
			for (MonthRecurrenceMode monthRecurrenceMode : MonthRecurrenceMode.values()) {
				for (TimeUnit timeUnit : TimeUnit.values()) {
					short key = (short) (2 + timeUnit.value + (monthRecurrenceMode.value << 8));
					RecurrenceInterval recurrenceInterval = RecurrenceInterval
							.fromTimeUnitInternal(timeUnit, monthRecurrenceMode);
					RecurrenceInterval.timeUnitToRecurrenceIntervalMap.put(key,
							recurrenceInterval);
				}
			}
		}

		public static RecurrenceInterval fromInt(short value) {
			RecurrenceInterval recurrenceInterval = RecurrenceInterval.map.get(value);
			return recurrenceInterval;
		}

		public static RecurrenceInterval fromTimeUnit(short timeUnitValue,
				byte monthRecurrenceModeValue) {
			short key = (short) (2 + timeUnitValue + (monthRecurrenceModeValue << 8));
			RecurrenceInterval recurrenceInterval = RecurrenceInterval.timeUnitToRecurrenceIntervalMap
					.get(key);
			return recurrenceInterval;
		}

		public static RecurrenceInterval fromTimeUnit(TimeUnit timeUnit,
				MonthRecurrenceMode monthRecurrenceMode) {
			RecurrenceInterval recurrenceInterval = RecurrenceInterval.fromTimeUnit(
					timeUnit.value, monthRecurrenceMode.value);
			return recurrenceInterval;
		}

		public static RecurrenceInterval fromTimeUnitInternal(TimeUnit timeUnit,
				MonthRecurrenceMode monthRecurrenceMode) {
			switch (timeUnit) {
			case ONE_TIME:
				return ONE_TIME;
			case MINUTE:
				return MINUTES;
			case HOUR:
				return HOURS;
			case DAY:
				return DAYS;
			case WEEK:
				return WEEKS;
			case MONTH:
				switch (monthRecurrenceMode) {
				case RECURRENT_ON_DATE:
					return MONTHS_ON_DATE;
				case RECURRENT_ON_NTH_WEEK_DAY:
					return MONTHS_ON_NTH_WEEK_DAY;
				default:
					return null;
				}
			case YEAR:
				return YEARS;
			default:
				return null;
			}
		}

		public static RecurrenceInterval fromString(String str) {
			RecurrenceInterval recurrenceInterval = RecurrenceInterval.stringToObjectMap
					.get(str);
			return recurrenceInterval;
		}
	}

	public enum MonthRecurrenceMode {
		RECURRENT_ON_DATE((byte) 1,
				R.id.fragment_edit_task_part_main_radio_monthly_recurrent_on_date), RECURRENT_ON_NTH_WEEK_DAY(
				(byte) 2,
				R.id.fragment_edit_task_part_main_radio_monthly_recurrent_on_nth_week_day);
		private byte value;
		private int radioButtonId;

		private MonthRecurrenceMode(byte value, int radioButtonId) {
			this.value = value;
			this.radioButtonId = radioButtonId;
		}

		public byte getValue() {
			return value;
		}

		public int getRadioButtonId() {
			return radioButtonId;
		}

		private static Map<Byte, MonthRecurrenceMode> map = new HashMap<Byte, MonthRecurrenceMode>();
		private static Map<Integer, MonthRecurrenceMode> radioButtonIdToMonthRecurrenceModeMap = new HashMap<Integer, MonthRecurrenceMode>();
		//private static Map<RecurrenceInterval, MonthRecurrenceMode> recurrenceIntervalToMonthRecurrenceModeMap = new HashMap<RecurrenceInterval, MonthRecurrenceMode>();
		static {
			for (MonthRecurrenceMode monthRecurrenceMode : MonthRecurrenceMode.values()) {
				MonthRecurrenceMode.map.put(monthRecurrenceMode.value,
						monthRecurrenceMode);
				MonthRecurrenceMode.radioButtonIdToMonthRecurrenceModeMap.put(
						monthRecurrenceMode.radioButtonId, monthRecurrenceMode);
			}
//			for (RecurrenceInterval recurrenceInterval : RecurrenceInterval.values()) {
//				MonthRecurrenceMode monthRecurrenceMode = MonthRecurrenceMode
//						.fromRecurrenceIntervalInternal(recurrenceInterval);
//				MonthRecurrenceMode.recurrenceIntervalToMonthRecurrenceModeMap.put(
//						recurrenceInterval, monthRecurrenceMode);
//			}
		}

		public static void initializeRecurrenceIntervalToMonthRecurrenceModeMap(
				Context context) {
			MonthRecurrenceMode monthRecurrenceModeFromPreference = MonthRecurrenceMode
					.fromInt((byte) Helper.getIntegerPreferenceValueFromStringArray(
							context, R.string.preference_key_month_recurrence_mode,
							R.array.month_recurrence_mode_values_array,
							R.integer.month_recurrence_mode_default_value));
//			for (RecurrenceInterval recurrenceInterval : RecurrenceInterval.values()) {
//				MonthRecurrenceMode monthRecurrenceMode = MonthRecurrenceMode
//						.fromRecurrenceIntervalInternal(recurrenceInterval);
//				if (monthRecurrenceMode == null) {
//					MonthRecurrenceMode.recurrenceIntervalToMonthRecurrenceModeMap.put(
//							recurrenceInterval, monthRecurrenceModeFromPreference);
//				} else {
//					MonthRecurrenceMode.recurrenceIntervalToMonthRecurrenceModeMap.put(
//							recurrenceInterval, monthRecurrenceMode);
//				}
//			}
		}

		public static MonthRecurrenceMode fromInt(byte value) {
			MonthRecurrenceMode monthRecurrenceMode = MonthRecurrenceMode.map.get(value);
			return monthRecurrenceMode;
		}

		private static MonthRecurrenceMode fromRecurrenceIntervalInternal(
				RecurrenceInterval recurrenceInterval) {
			switch (recurrenceInterval) {
			case MONTHS_ON_DATE:
				return RECURRENT_ON_DATE;
			case MONTHS_ON_NTH_WEEK_DAY:
				return RECURRENT_ON_NTH_WEEK_DAY;
			default:
				return null;
			}
		}

		public static MonthRecurrenceMode fromRecurrenceInterval(Context context, RecurrenceInterval value) {
			MonthRecurrenceMode monthRecurrenceMode = MonthRecurrenceMode.fromRecurrenceIntervalInternal
					(value);
			if (monthRecurrenceMode == null) {
				MonthRecurrenceMode monthRecurrenceModeFromPreference = MonthRecurrenceMode
						.fromInt((byte) Helper.getIntegerPreferenceValueFromStringArray(
								context, R.string.preference_key_month_recurrence_mode,
								R.array.month_recurrence_mode_values_array,
								R.integer.month_recurrence_mode_default_value));
				return monthRecurrenceModeFromPreference;
			} else {
				return monthRecurrenceMode;
			}
		}

		public static MonthRecurrenceMode fromRadioGroup(RadioGroup radioGroup) {
			MonthRecurrenceMode monthRecurrenceMode = MonthRecurrenceMode
					.fromRadioButtonId(radioGroup.getCheckedRadioButtonId());
			if (monthRecurrenceMode == null) {
				int monthRecurrenceModeValue = Helper
						.getIntegerPreferenceValueFromStringArray(
								radioGroup.getContext(),
								R.string.preference_key_month_recurrence_mode,
								R.array.month_recurrence_mode_values_array,
								R.integer.month_recurrence_mode_default_value);
				monthRecurrenceMode = MonthRecurrenceMode
						.fromInt((byte) monthRecurrenceModeValue);
				RadioButton radioButton = (RadioButton) radioGroup
						.findViewById(monthRecurrenceMode.radioButtonId);
				radioButton.setChecked(true);
			}
			return monthRecurrenceMode;
		}

		public static MonthRecurrenceMode fromRadioButtonId(int radioButtonId) {
			MonthRecurrenceMode monthRecurrenceMode = MonthRecurrenceMode.radioButtonIdToMonthRecurrenceModeMap
					.get(radioButtonId);
			return monthRecurrenceMode;
		}
	}

	public enum SyncPolicy {
		DO_SYNC((byte) 1), DO_NOT_SYNC((byte) 2), ;
		private byte value;

		private SyncPolicy(byte value) {
			this.value = value;
		}

		public byte getValue() {
			return value;
		}

		private static Map<Byte, SyncPolicy> map = new HashMap<Byte, SyncPolicy>();
		private static Map<String, SyncPolicy> stringToObjectMap = new HashMap<String, SyncPolicy>();
		static {
			for (SyncPolicy syncPolicy : SyncPolicy.values()) {
				SyncPolicy.map.put(syncPolicy.value, syncPolicy);
				SyncPolicy.stringToObjectMap.put(syncPolicy.name(), syncPolicy);
			}
		}

		public static SyncPolicy fromInt(byte value) {
			SyncPolicy syncPolicy = SyncPolicy.map.get(value);
			return syncPolicy;
		}

		public static SyncPolicy fromString(String name) {
			SyncPolicy syncPolicy = SyncPolicy.stringToObjectMap.get(name);
			return syncPolicy;
		}
	}

	public enum MarkSyncNeededPolicy {
		ALWAYS((byte) 1), IF_SYNC_IS_SWITCHED_ON((byte) 2), NEVER((byte) 3), ;
		private byte value;

		private MarkSyncNeededPolicy(byte value) {
			this.value = value;
		}

		public byte getValue() {
			return value;
		}

		private static Map<Byte, MarkSyncNeededPolicy> map = new HashMap<Byte, MarkSyncNeededPolicy>();
		private static Map<String, MarkSyncNeededPolicy> stringToObjectMap = new HashMap<String, MarkSyncNeededPolicy>();
		static {
			for (MarkSyncNeededPolicy markSyncNeeded : MarkSyncNeededPolicy.values()) {
				MarkSyncNeededPolicy.map.put(markSyncNeeded.value, markSyncNeeded);
				MarkSyncNeededPolicy.stringToObjectMap.put(markSyncNeeded.name(),
						markSyncNeeded);
			}
		}

		public static MarkSyncNeededPolicy fromInt(byte value) {
			MarkSyncNeededPolicy markSyncNeeded = MarkSyncNeededPolicy.map.get(value);
			return markSyncNeeded;
		}

		public static MarkSyncNeededPolicy fromString(String name) {
			MarkSyncNeededPolicy markSyncNeeded = MarkSyncNeededPolicy.stringToObjectMap
					.get(name);
			return markSyncNeeded;
		}
	}

	public enum SyncStatus {
		SYNCHRONIZED((byte) 1), SYNC_UP_REQUIRED((byte) 2), SYNC_DOWN_REQUIRED((byte) 4);
		private byte value;

		private SyncStatus(byte value) {
			this.value = value;
		}

		/** @return the value */
		public byte getValue() {
			return value;
		}

		public static SyncStatus fromInt(int x) {
			switch (x) {
			case 1:
				return SYNCHRONIZED;
			case 2:
				return SYNC_UP_REQUIRED;
			case 4:
				return SYNC_DOWN_REQUIRED;
			default:
				return null;
			}
		}
	}

	// public enum PrePostBusinessHoursTaskOccurrenceDistributionMode {
	// SHOW_PRE_POST_AND_BUSINESS_HOURS_SEPARATELY((byte) 1),
	// SHOW_PRE_AND_POST_IN_BUSINESS_HOURS(
	// (byte) 2), DO_NOT_SHOW_PRE_AND_POST_BUSINESS_HOURS((byte) 3), ;
	// private byte value;
	//
	// private PrePostBusinessHoursTaskOccurrenceDistributionMode(byte value) {
	// this.value = value;
	// }
	//
	// public byte getValue() {
	// return value;
	// }
	//
	// private static Map<Byte, TaskEditMode> map = new HashMap<Byte, TaskEditMode>();
	// private static Map<String, TaskEditMode> stringToObjectMap = new HashMap<String,
	// TaskEditMode>();
	// static {
	// for (TaskEditMode taskEditMode : TaskEditMode.values()) {
	// TaskEditMode.map.put(taskEditMode.value, taskEditMode);
	// TaskEditMode.stringToObjectMap.put(taskEditMode.name(), taskEditMode);
	// }
	// }
	//
	// public static TaskEditMode fromInt(byte value) {
	// TaskEditMode taskEditMode = TaskEditMode.map.get(value);
	// return taskEditMode;
	// }
	//
	// public static TaskEditMode fromString(String name) {
	// TaskEditMode taskEditMode = TaskEditMode.stringToObjectMap.get(name);
	// return taskEditMode;
	// }
	// }
	class TaskOccurrenceComparator implements Comparator<TaskOccurrence> {
		@Override
		public int compare(TaskOccurrence lhs, TaskOccurrence rhs) {
			if (lhs.getOrdinalNumber() < rhs.getOrdinalNumber()) {
				return -1;
			} else if (lhs.getOrdinalNumber() == rhs.getOrdinalNumber()) {
				return 0;
			} else {
				return 1;
			}
		}
	}

	class TaskOccurrenceComparatorWeek implements Comparator<TaskOccurrence> {
		private int mFirstDayOfWeek;

		public TaskOccurrenceComparatorWeek(int firstDayOfWeek) {
			mFirstDayOfWeek = firstDayOfWeek;
		}

		@Override
		public int compare(TaskOccurrence lhs, TaskOccurrence rhs) {
			int lhsValue = lhs.getOrdinalNumber();
			int rhsValue = rhs.getOrdinalNumber();
			if (lhsValue < mFirstDayOfWeek && rhsValue < mFirstDayOfWeek
					|| lhsValue >= mFirstDayOfWeek && rhsValue >= mFirstDayOfWeek) {
				if (lhsValue < rhsValue) {
					return -1;
				} else if (lhsValue == rhsValue) {
					return 0;
				} else {
					return 1;
				}
			} else if (lhsValue < mFirstDayOfWeek && rhsValue >= mFirstDayOfWeek) {
				return 1;
			} else {
				return -1;
			}
		}
	}

	// KEEP FIELDS END
	public Task() {
	}

	public Task(Long id) {
		this.id = id;
	}

	public Task(Long id, Long calendarId, Long parentId, long localCreateDateTime,
			long localChangeDateTime, Long serverId, Long created, Long lastMod,
			byte syncStatusValue, String name, short priority, Integer color,
			Long startDateTime, Long endDateTime, Integer requiredLength,
			Integer actualLength, boolean isCompleted, short percentOfCompletion,
			Long completedTime, boolean deleted, int sortOrder, String description,
			String location, short recurrenceIntervalValue, Integer timeUnitsCount,
			Integer occurrencesMaxCount, Long repetitionEndDateTime,
			String alarmRingtone, String notificationRingtone, Long ringtoneFadeInTime,
			Integer playingTime, Integer automaticSnoozeDuration,
			Integer automaticSnoozesMaxCount, Boolean vibrate, String vibratePattern,
			Boolean led, String ledPattern, Integer ledColor) {
		this.id = id;
		this.calendarId = calendarId;
		this.parentId = parentId;
		this.localCreateDateTime = localCreateDateTime;
		this.localChangeDateTime = localChangeDateTime;
		this.serverId = serverId;
		this.created = created;
		this.lastMod = lastMod;
		this.syncStatusValue = syncStatusValue;
		this.name = name;
		this.priority = priority;
		this.color = color;
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
		this.requiredLength = requiredLength;
		this.actualLength = actualLength;
		this.isCompleted = isCompleted;
		this.percentOfCompletion = percentOfCompletion;
		this.completedTime = completedTime;
		this.deleted = deleted;
		this.sortOrder = sortOrder;
		this.description = description;
		this.location = location;
		this.recurrenceIntervalValue = recurrenceIntervalValue;
		this.timeUnitsCount = timeUnitsCount;
		this.occurrencesMaxCount = occurrencesMaxCount;
		this.repetitionEndDateTime = repetitionEndDateTime;
		this.alarmRingtone = alarmRingtone;
		this.notificationRingtone = notificationRingtone;
		this.ringtoneFadeInTime = ringtoneFadeInTime;
		this.playingTime = playingTime;
		this.automaticSnoozeDuration = automaticSnoozeDuration;
		this.automaticSnoozesMaxCount = automaticSnoozesMaxCount;
		this.vibrate = vibrate;
		this.vibratePattern = vibratePattern;
		this.led = led;
		this.ledPattern = ledPattern;
		this.ledColor = ledColor;
	}

	/** called by internal mechanisms, do not call yourself. */
	public void __setDaoSession(DaoSession daoSession) {
		this.daoSession = daoSession;
		myDao = daoSession != null ? daoSession.getTaskDao() : null;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Long getCalendarId() {
		return calendarId;
	}

	public void setCalendarId(Long calendarId) {
		this.calendarId = calendarId;
	}

	public Long getParentId() {
		return parentId;
	}

	public void setParentId(Long parentId) {
		this.parentId = parentId;
	}

	public long getLocalCreateDateTime() {
		return localCreateDateTime;
	}

	public void setLocalCreateDateTime(long localCreateDateTime) {
		this.localCreateDateTime = localCreateDateTime;
	}

	public long getLocalChangeDateTime() {
		return localChangeDateTime;
	}

	public void setLocalChangeDateTime(long localChangeDateTime) {
		this.localChangeDateTime = localChangeDateTime;
	}

	public Long getServerId() {
		return serverId;
	}

	public void setServerId(Long serverId) {
		this.serverId = serverId;
	}

	public Long getCreated() {
		return created;
	}

	public void setCreated(Long created) {
		this.created = created;
	}

	public Long getLastMod() {
		return lastMod;
	}

	public void setLastMod(Long lastMod) {
		this.lastMod = lastMod;
	}

	public byte getSyncStatusValue() {
		return syncStatusValue;
	}

	public void setSyncStatusValue(byte syncStatusValue) {
		this.syncStatusValue = syncStatusValue;
	}

	/** Not-null value. */
	public String getName() {
		return name;
	}

	/** Not-null value; ensure this value is available before it is saved to the database. */
	public void setName(String name) {
		this.name = name;
	}

	public short getPriority() {
		return priority;
	}

	public void setPriority(short priority) {
		this.priority = priority;
	}

	public Integer getColor() {
		return color;
	}

	public void setColor(Integer color) {
		this.color = color;
	}

	public Long getStartDateTime() {
		return startDateTime;
	}

	public void setStartDateTime(Long startDateTime) {
		this.startDateTime = startDateTime;
	}

	public Long getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(Long endDateTime) {
		this.endDateTime = endDateTime;
	}

	public Integer getRequiredLength() {
		return requiredLength;
	}

	public void setRequiredLength(Integer requiredLength) {
		this.requiredLength = requiredLength;
	}

	public Integer getActualLength() {
		return actualLength;
	}

	public void setActualLength(Integer actualLength) {
		this.actualLength = actualLength;
	}

	public boolean getIsCompleted() {
		return isCompleted;
	}

	public void setIsCompleted(boolean isCompleted) {
		this.isCompleted = isCompleted;
	}

	public short getPercentOfCompletion() {
		return percentOfCompletion;
	}

	public void setPercentOfCompletion(short percentOfCompletion) {
		this.percentOfCompletion = percentOfCompletion;
	}

	public Long getCompletedTime() {
		return completedTime;
	}

	public void setCompletedTime(Long completedTime) {
		this.completedTime = completedTime;
	}

	public boolean getDeleted() {
		return deleted;
	}

	public void setDeleted(boolean deleted) {
		this.deleted = deleted;
	}

	public int getSortOrder() {
		return sortOrder;
	}

	public void setSortOrder(int sortOrder) {
		this.sortOrder = sortOrder;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public short getRecurrenceIntervalValue() {
		return recurrenceIntervalValue;
	}

	public void setRecurrenceIntervalValue(short recurrenceIntervalValue) {
		this.recurrenceIntervalValue = recurrenceIntervalValue;
	}

	public Integer getTimeUnitsCount() {
		return timeUnitsCount;
	}

	public void setTimeUnitsCount(Integer timeUnitsCount) {
		this.timeUnitsCount = timeUnitsCount;
	}

	public Integer getOccurrencesMaxCount() {
		return occurrencesMaxCount;
	}

	public void setOccurrencesMaxCount(Integer occurrencesMaxCount) {
		this.occurrencesMaxCount = occurrencesMaxCount;
	}

	public Long getRepetitionEndDateTime() {
		return repetitionEndDateTime;
	}

	public void setRepetitionEndDateTime(Long repetitionEndDateTime) {
		this.repetitionEndDateTime = repetitionEndDateTime;
	}

	public String getAlarmRingtone() {
		return alarmRingtone;
	}

	public void setAlarmRingtone(String alarmRingtone) {
		this.alarmRingtone = alarmRingtone;
	}

	public String getNotificationRingtone() {
		return notificationRingtone;
	}

	public void setNotificationRingtone(String notificationRingtone) {
		this.notificationRingtone = notificationRingtone;
	}

	public Long getRingtoneFadeInTime() {
		return ringtoneFadeInTime;
	}

	public void setRingtoneFadeInTime(Long ringtoneFadeInTime) {
		this.ringtoneFadeInTime = ringtoneFadeInTime;
	}

	public Integer getPlayingTime() {
		return playingTime;
	}

	public void setPlayingTime(Integer playingTime) {
		this.playingTime = playingTime;
	}

	public Integer getAutomaticSnoozeDuration() {
		return automaticSnoozeDuration;
	}

	public void setAutomaticSnoozeDuration(Integer automaticSnoozeDuration) {
		this.automaticSnoozeDuration = automaticSnoozeDuration;
	}

	public Integer getAutomaticSnoozesMaxCount() {
		return automaticSnoozesMaxCount;
	}

	public void setAutomaticSnoozesMaxCount(Integer automaticSnoozesMaxCount) {
		this.automaticSnoozesMaxCount = automaticSnoozesMaxCount;
	}

	public Boolean getVibrate() {
		return vibrate;
	}

	public void setVibrate(Boolean vibrate) {
		this.vibrate = vibrate;
	}

	public String getVibratePattern() {
		return vibratePattern;
	}

	public void setVibratePattern(String vibratePattern) {
		this.vibratePattern = vibratePattern;
	}

	public Boolean getLed() {
		return led;
	}

	public void setLed(Boolean led) {
		this.led = led;
	}

	public String getLedPattern() {
		return ledPattern;
	}

	public void setLedPattern(String ledPattern) {
		this.ledPattern = ledPattern;
	}

	public Integer getLedColor() {
		return ledColor;
	}

	public void setLedColor(Integer ledColor) {
		this.ledColor = ledColor;
	}

	/** To-one relationship, resolved on first access. */
	public biz.advancedcalendar.greendao.Calendar getCalendar() {
		Long __key = calendarId;
		if (calendar__resolvedKey == null || !calendar__resolvedKey.equals(__key)) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			CalendarDao targetDao = daoSession.getCalendarDao();
			biz.advancedcalendar.greendao.Calendar calendarNew = targetDao.load(__key);
			synchronized (this) {
				calendar = calendarNew;
				calendar__resolvedKey = __key;
			}
		}
		return calendar;
	}

	public void setCalendar(biz.advancedcalendar.greendao.Calendar calendar) {
		synchronized (this) {
			this.calendar = calendar;
			calendarId = calendar == null ? null : calendar.getId();
			calendar__resolvedKey = calendarId;
		}
	}

	/** To-one relationship, resolved on first access. */
	public Task getTask() {
		Long __key = parentId;
		if (task__resolvedKey == null || !task__resolvedKey.equals(__key)) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			TaskDao targetDao = daoSession.getTaskDao();
			Task taskNew = targetDao.load(__key);
			synchronized (this) {
				task = taskNew;
				task__resolvedKey = __key;
			}
		}
		return task;
	}

	public void setTask(Task task) {
		synchronized (this) {
			this.task = task;
			parentId = task == null ? null : task.getId();
			task__resolvedKey = parentId;
		}
	}

	/** To-many relationship, resolved on first access (and after reset). Changes to
	 * to-many relations are not persisted, make changes to the target entity. */
	public List<TaskOccurrence> getTaskOccurrenceList() {
		if (taskOccurrenceList == null) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			TaskOccurrenceDao targetDao = daoSession.getTaskOccurrenceDao();
			List<TaskOccurrence> taskOccurrenceListNew = targetDao
					._queryTask_TaskOccurrenceList(id);
			synchronized (this) {
				if (taskOccurrenceList == null) {
					taskOccurrenceList = taskOccurrenceListNew;
				}
			}
		}
		return taskOccurrenceList;
	}

	/** Resets a to-many relationship, making the next get call to query for a fresh
	 * result. */
	public synchronized void resetTaskOccurrenceList() {
		taskOccurrenceList = null;
	}

	/** To-many relationship, resolved on first access (and after reset). Changes to
	 * to-many relations are not persisted, make changes to the target entity. */
	public List<Reminder> getReminderList() {
		if (reminderList == null) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			ReminderDao targetDao = daoSession.getReminderDao();
			List<Reminder> reminderListNew = targetDao._queryTask_ReminderList(id);
			synchronized (this) {
				if (reminderList == null) {
					reminderList = reminderListNew;
				}
			}
		}
		return reminderList;
	}

	/** Resets a to-many relationship, making the next get call to query for a fresh
	 * result. */
	public synchronized void resetReminderList() {
		reminderList = null;
	}

	/** To-many relationship, resolved on first access (and after reset). Changes to
	 * to-many relations are not persisted, make changes to the target entity. */
	public List<TaskLabel> getTaskLabelList() {
		if (taskLabelList == null) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			TaskLabelDao targetDao = daoSession.getTaskLabelDao();
			List<TaskLabel> taskLabelListNew = targetDao._queryTask_TaskLabelList(id);
			synchronized (this) {
				if (taskLabelList == null) {
					taskLabelList = taskLabelListNew;
				}
			}
		}
		return taskLabelList;
	}

	/** Resets a to-many relationship, making the next get call to query for a fresh
	 * result. */
	public synchronized void resetTaskLabelList() {
		taskLabelList = null;
	}

	/** To-many relationship, resolved on first access (and after reset). Changes to
	 * to-many relations are not persisted, make changes to the target entity. */
	public List<TaskContact> getTaskContactList() {
		if (taskContactList == null) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			TaskContactDao targetDao = daoSession.getTaskContactDao();
			List<TaskContact> taskContactListNew = targetDao
					._queryTask_TaskContactList(id);
			synchronized (this) {
				if (taskContactList == null) {
					taskContactList = taskContactListNew;
				}
			}
		}
		return taskContactList;
	}

	/** Resets a to-many relationship, making the next get call to query for a fresh
	 * result. */
	public synchronized void resetTaskContactList() {
		taskContactList = null;
	}

	/** To-many relationship, resolved on first access (and after reset). Changes to
	 * to-many relations are not persisted, make changes to the target entity. */
	public List<FileTask> getFileTaskList() {
		if (fileTaskList == null) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			FileTaskDao targetDao = daoSession.getFileTaskDao();
			List<FileTask> fileTaskListNew = targetDao._queryTask_FileTaskList(id);
			synchronized (this) {
				if (fileTaskList == null) {
					fileTaskList = fileTaskListNew;
				}
			}
		}
		return fileTaskList;
	}

	/** Resets a to-many relationship, making the next get call to query for a fresh
	 * result. */
	public synchronized void resetFileTaskList() {
		fileTaskList = null;
	}

	/** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an
	 * entity context. */
	public void delete() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.delete(this);
	}

	/** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an
	 * entity context. */
	public void update() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.update(this);
	}

	/** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an
	 * entity context. */
	public void refresh() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.refresh(this);
	}

	// KEEP METHODS - put your custom methods here
	public Task(Task task) {
		this(task.id, task.calendarId, task.parentId, task.localCreateDateTime,
				task.localChangeDateTime, task.serverId, task.created, task.lastMod,
				task.syncStatusValue, task.name, task.priority, task.color,
				task.startDateTime, task.endDateTime, task.requiredLength,
				task.actualLength, task.isCompleted, task.percentOfCompletion,
				task.completedTime, task.deleted, task.sortOrder, task.description,
				task.location, task.recurrenceIntervalValue, task.timeUnitsCount,
				task.occurrencesMaxCount, task.repetitionEndDateTime, task.alarmRingtone,
				task.notificationRingtone, task.ringtoneFadeInTime, task.playingTime,
				task.automaticSnoozeDuration, task.automaticSnoozesMaxCount,
				task.vibrate, task.vibratePattern, task.led, task.ledPattern,
				task.ledColor);
	}

	public short getDeepLevel() {
		class ShortHolder {
			short value = 0;
		}
		final ShortHolder shortHolder = new ShortHolder();
		daoSession.runInTx(new Runnable() {
			@Override
			public void run() {
				Long localParentId = getParentId();
				TaskDao dao = daoSession.getTaskDao();
				while (localParentId != null) {
					shortHolder.value++;
					localParentId = dao.load(localParentId).getParentId();
				}
			}
		});
		return shortHolder.value;
	}

	// public Long getPreviousOccurrenceStartDateTime2(Context context,
	// long controlDateTime, boolean includeEventsMatchingControlDateTime,
	// int firstDayOfWeek) {
	// switch (RecurrenceInterval.fromInt(recurrenceIntervalValue)) {
	// case ONE_TIME:
	// return getPreviousOccurrenceStartDateTimeOfOneTimeTask(context,
	// controlDateTime, includeEventsMatchingControlDateTime);
	// case DAYS:
	// case WEEKS:
	// case HOURS:
	// case MINUTES:
	// case MONTHS_ON_DATE:
	// case MONTHS_ON_NTH_WEEK_DAY:
	// case YEARS:
	// default:
	// return getNearestOccurrenceStartDateTimeOfRecurringTask(context,
	// controlDateTime, includeEventsMatchingControlDateTime, true,
	// firstDayOfWeek);
	// }
	// }
	public Long getNearestOccurrenceStartDateTime(long controlDateTime,
			boolean includeEventsMatchingControlDateTime, boolean searchPrevious,
			int firstDayOfWeek) {
		switch (RecurrenceInterval.fromInt(recurrenceIntervalValue)) {
		case ONE_TIME:
			if (searchPrevious) {
				return getPreviousOccurrenceStartDateTimeOfOneTimeTask(controlDateTime,
						includeEventsMatchingControlDateTime);
			} else {
				return getNextOccurrenceStartDateTimeOfOneTimeTask(controlDateTime,
						includeEventsMatchingControlDateTime);
			}
		case DAYS:
		case WEEKS:
		case HOURS:
		case MINUTES:
		case MONTHS_ON_DATE:
		case MONTHS_ON_NTH_WEEK_DAY:
		case YEARS:
		default:
			Long borderStartDateTime = null;
			Long borderEndDateTime = null;
			if (searchPrevious) {
				borderEndDateTime = controlDateTime;
			} else {
				borderStartDateTime = controlDateTime;
			}
			List<CalendarViewTaskOccurrence> calendarViewTaskOccurrences = selectTaskOccurrencesOfRecurrentTask(
					borderStartDateTime, borderEndDateTime,
					includeEventsMatchingControlDateTime, null, firstDayOfWeek);
			if (calendarViewTaskOccurrences.size() == 0) {
				return null;
			} else {
				return calendarViewTaskOccurrences.get(0).StartDateTime;
			}
		}
	}

	private Long getPreviousOccurrenceStartDateTimeOfOneTimeTask(long controlDateTime,
			boolean includeEventsMatchingControlDateTime) {
		if (startDateTime != null
				&& (includeEventsMatchingControlDateTime
						&& startDateTime <= controlDateTime || !includeEventsMatchingControlDateTime
						&& startDateTime < controlDateTime)) {
			return startDateTime;
		} else {
			return null;
		}
	}

	private Long getNextOccurrenceStartDateTimeOfOneTimeTask(long controlDateTime,
			boolean includeEventsMatchingControlDateTime) {
		if (startDateTime != null
				&& (includeEventsMatchingControlDateTime
						&& controlDateTime <= startDateTime || !includeEventsMatchingControlDateTime
						&& controlDateTime < startDateTime)) {
			return startDateTime;
		} else {
			return null;
		}
	}

	// private Long getPreviousOccurrenceStartDateTimeOfRecurringTask(Context context,
	// long controlDateTime, boolean includeEventsMatchingControlDateTime,
	// int firstDayOfWeek) {
	// Long previousOccurrenceStartDateTime = null;
	// List<TaskOccurrence> taskOccurrences = getTaskOccurrenceList();
	// RecurrenceInterval recurrenceInterval = RecurrenceInterval
	// .fromInt(recurrenceIntervalValue);
	// int count;
	// if (recurrenceInterval.equals(RecurrenceInterval.MONTHS_ON_NTH_WEEK_DAY)) {
	// count = taskOccurrences.size() - 1;
	// } else {
	// count = taskOccurrences.size();
	// }
	// if (count <= 0) {
	// return null;
	// }
	// DateTime borderStartDateTime = new DateTime(controlDateTime);
	// DateTime currentPeriodBeginning;
	// int startDateTimeMillisOfDay = new DateTime(startDateTime).getMillisOfDay();
	// if (recurrenceInterval.equals(RecurrenceInterval.WEEKS)) {
	// currentPeriodBeginning = new DateTime(Helper.getBeginningOfWeek(
	// startDateTime, firstDayOfWeek))
	// .withMillisOfDay(startDateTimeMillisOfDay);
	// } else if (recurrenceInterval.equals(RecurrenceInterval.MONTHS_ON_DATE)) {
	// currentPeriodBeginning = new DateTime(startDateTime).withDayOfMonth(1);
	// } else if (recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
	// currentPeriodBeginning = new DateTime(startDateTime).withDayOfYear(1);
	// } else {
	// currentPeriodBeginning = new DateTime(startDateTime);
	// }
	// List<DateTime> taskOccurrencesStartDateTimes = new ArrayList<DateTime>(count);
	// int month;
	// int year;
	// int weekCode = taskOccurrences.get(taskOccurrences.size() - 1).getOrdinalNumber();
	// //
	// if (!recurrenceInterval.equals(RecurrenceInterval.MONTHS_ON_NTH_WEEK_DAY)) {
	// if (recurrenceInterval.equals(RecurrenceInterval.WEEKS)) {
	// Collections.sort(taskOccurrences, new TaskOccurrenceComparatorWeek(
	// firstDayOfWeek));
	// } else {
	// Collections.sort(taskOccurrences, new TaskOccurrenceComparator());
	// }
	// }
	// int currentTaskOccurrencesCount = 0;
	// boolean isDayFebruary28Checked = false;
	// boolean isDayFebruary29Checked = false;
	// boolean isDayFebruaryLastChecked = false;
	// if (recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
	// for (TaskOccurrence taskOccurrence : taskOccurrences) {
	// if (taskOccurrence.getOrdinalNumber() == 59) {
	// isDayFebruary28Checked = true;
	// }
	// if (taskOccurrence.getOrdinalNumber() == 60) {
	// isDayFebruary29Checked = true;
	// }
	// if (taskOccurrence.getOrdinalNumber() == 61) {
	// isDayFebruaryLastChecked = true;
	// }
	// }
	// }
	// int countNotIn_28_29_last = 0;
	// if (recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
	// for (TaskOccurrence taskOccurrence : taskOccurrences) {
	// int dayCode = taskOccurrence.getOrdinalNumber();
	// if (dayCode < 59 || dayCode > 61) {
	// countNotIn_28_29_last++;
	// }
	// }
	// }
	// while (true) {
	// taskOccurrencesStartDateTimes.clear();
	// DateTime supposedTaskOccurrenceStartDateTime;
	// switch (recurrenceInterval) {
	// case MONTHS_ON_NTH_WEEK_DAY:
	// // we get here zero-based month (zero-based month is used in function
	// // getNthOfMonth())
	// month = currentPeriodBeginning.getMonthOfYear() - 1;
	// year = currentPeriodBeginning.getYear();
	// for (int i = 0; i < count; i++) {
	// supposedTaskOccurrenceStartDateTime = new DateTime(getNthOfMonth(
	// weekCode, taskOccurrences.get(i).getOrdinalNumber(), month,
	// year)).withMillisOfDay(startDateTimeMillisOfDay);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime.getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// break;
	// case MINUTES:
	// for (TaskOccurrence taskOccurrence : taskOccurrences) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusMinutes(taskOccurrence.getOrdinalNumber() - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime.getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// break;
	// case HOURS:
	// for (TaskOccurrence taskOccurrence : taskOccurrences) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusHours(taskOccurrence.getOrdinalNumber() - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime.getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// break;
	// case WEEKS:
	// for (TaskOccurrence taskOccurrence : taskOccurrences) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(firstDayOfWeek <= taskOccurrence.getOrdinalNumber() ? taskOccurrence
	// .getOrdinalNumber() - firstDayOfWeek
	// : taskOccurrence.getOrdinalNumber() - firstDayOfWeek
	// + 7);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime.getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// break;
	// case DAYS:
	// case MONTHS_ON_DATE:
	// boolean isLastDayAlreadyWasTriedToAdd = false;
	// for (TaskOccurrence taskOccurrence : taskOccurrences) {
	// int day = taskOccurrence.getOrdinalNumber();
	// boolean tryToAdd = true;
	// switch (day) {
	// case 28:
	// int lastDay = currentPeriodBeginning.dayOfMonth()
	// .withMaximumValue().dayOfMonth().get();
	// if (lastDay == 28) {
	// isLastDayAlreadyWasTriedToAdd = true;
	// }
	// break;
	// case 29:
	// if (!isLastDayAlreadyWasTriedToAdd) {
	// int month1 = currentPeriodBeginning.getMonthOfYear();
	// if (month1 == 2) {
	// boolean isLeap = currentPeriodBeginning.property(
	// DateTimeFieldType.year()).isLeap();
	// if (!isLeap) {
	// tryToAdd = false;
	// }
	// }
	// lastDay = currentPeriodBeginning.dayOfMonth()
	// .withMaximumValue().dayOfMonth().get();
	// if (lastDay == 29) {
	// isLastDayAlreadyWasTriedToAdd = true;
	// }
	// }
	// break;
	// case 30:
	// if (!isLastDayAlreadyWasTriedToAdd) {
	// int month1 = currentPeriodBeginning.getMonthOfYear();
	// if (month1 == 2) {
	// tryToAdd = false;
	// }
	// lastDay = currentPeriodBeginning.dayOfMonth()
	// .withMaximumValue().dayOfMonth().get();
	// if (lastDay == 30) {
	// isLastDayAlreadyWasTriedToAdd = true;
	// }
	// break;
	// }
	// case 31:
	// if (!isLastDayAlreadyWasTriedToAdd) {
	// int month1 = currentPeriodBeginning.getMonthOfYear();
	// if (month1 == 2 || month1 == 4 || month1 == 6 || month1 == 9
	// || month1 == 11) {
	// tryToAdd = false;
	// }
	// lastDay = currentPeriodBeginning.dayOfMonth()
	// .withMaximumValue().dayOfMonth().get();
	// if (lastDay == 31) {
	// isLastDayAlreadyWasTriedToAdd = true;
	// }
	// break;
	// }
	// case 32:
	// if (!isLastDayAlreadyWasTriedToAdd) {
	// // int month1 = currentPeriodBeginning.getMonthOfYear();
	// if (isLastDayAlreadyWasTriedToAdd) {
	// tryToAdd = false;
	// } else {
	// day = currentPeriodBeginning.dayOfMonth()
	// .withMaximumValue().dayOfMonth().get();
	// }
	// break;
	// } else {
	// tryToAdd = false;
	// }
	// default:
	// break;
	// }
	// if (tryToAdd) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(day - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// }
	// break;
	// case YEARS:
	// boolean isLeap = currentPeriodBeginning
	// .property(DateTimeFieldType.year()).isLeap();
	// if (isDayFebruary28Checked
	// && (isDayFebruary29Checked || isDayFebruaryLastChecked)) {
	// if (isLeap) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(59 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(60 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// } else {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(59 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// } else if (isDayFebruary28Checked && !isDayFebruary29Checked
	// && !isDayFebruaryLastChecked) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(59 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime.getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// } else if (!isDayFebruary28Checked && isDayFebruary29Checked
	// && isDayFebruaryLastChecked) {
	// if (isLeap) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(60 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// } else {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(59 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// } else if (!isDayFebruary28Checked && isDayFebruary29Checked
	// && !isDayFebruaryLastChecked) {
	// if (isLeap) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(60 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// } else if (!isDayFebruary28Checked && !isDayFebruary29Checked
	// && isDayFebruaryLastChecked) {
	// if (isLeap) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(60 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// } else {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(59 - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// }
	// for (TaskOccurrence taskOccurrence : taskOccurrences) {
	// int dayCode = taskOccurrence.getOrdinalNumber();
	// if (dayCode < 59) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(dayCode - 1);
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// } else if (dayCode > 61) {
	// if (isLeap) {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(dayCode - 2);
	// } else {
	// supposedTaskOccurrenceStartDateTime = currentPeriodBeginning
	// .plusDays(dayCode - 3);
	// }
	// if (startDateTime <= supposedTaskOccurrenceStartDateTime
	// .getMillis()) {
	// taskOccurrencesStartDateTimes
	// .add(supposedTaskOccurrenceStartDateTime);
	// }
	// }
	// }
	// break;
	// case ONE_TIME:
	// throw new IllegalArgumentException(
	// "getPreviousOccurrenceStartDateTimeOfRecurringTask() has been called on Task with recurrence interval ONE_TIME");
	// }
	// Collections.sort(taskOccurrencesStartDateTimes);
	// for (DateTime currentTaskOccurrenceStartDateTime : taskOccurrencesStartDateTimes) {
	// currentTaskOccurrencesCount++;
	// long currentTaskOccurrenceStartDateTimeMillis = currentTaskOccurrenceStartDateTime
	// .getMillis();
	// if (repetitionEndDateTime != null
	// && repetitionEndDateTime <= currentTaskOccurrenceStartDateTimeMillis
	// || occurrencesMaxCount != null
	// && occurrencesMaxCount < currentTaskOccurrencesCount
	// //
	// || includeEventsMatchingControlDateTime
	// && controlDateTime <= currentTaskOccurrenceStartDateTimeMillis
	// || !includeEventsMatchingControlDateTime
	// && controlDateTime < currentTaskOccurrenceStartDateTimeMillis) {
	// if (previousOccurrenceStartDateTime != null
	// && (includeEventsMatchingControlDateTime
	// && previousOccurrenceStartDateTime <= controlDateTime ||
	// !includeEventsMatchingControlDateTime
	// && previousOccurrenceStartDateTime < controlDateTime)) {
	// return previousOccurrenceStartDateTime;
	// } else {
	// return null;
	// }
	// }
	// previousOccurrenceStartDateTime = currentTaskOccurrenceStartDateTimeMillis;
	// }
	// //
	// int wholePeriodsCount = 1;
	// boolean isBorderStartDateTimeGreater = currentPeriodBeginning.getMillis() <
	// borderStartDateTime
	// .getMillis();
	// switch (recurrenceInterval) {
	// case MINUTES:
	// if (isBorderStartDateTimeGreater) {
	// wholePeriodsCount = Minutes.minutesBetween(currentPeriodBeginning,
	// borderStartDateTime).getMinutes()
	// / timeUnitsCount;
	// }
	// currentPeriodBeginning = currentPeriodBeginning
	// .plusMinutes((wholePeriodsCount = Math.max(1, wholePeriodsCount))
	// * timeUnitsCount);
	// break;
	// case HOURS:
	// if (isBorderStartDateTimeGreater) {
	// wholePeriodsCount = Hours.hoursBetween(currentPeriodBeginning,
	// borderStartDateTime).getHours()
	// / timeUnitsCount;
	// }
	// currentPeriodBeginning = currentPeriodBeginning
	// .plusHours((wholePeriodsCount = Math.max(1, wholePeriodsCount))
	// * timeUnitsCount);
	// break;
	// case DAYS:
	// if (isBorderStartDateTimeGreater) {
	// wholePeriodsCount = Days.daysBetween(currentPeriodBeginning,
	// borderStartDateTime).getDays()
	// / timeUnitsCount;
	// }
	// currentPeriodBeginning = currentPeriodBeginning
	// .plusDays((wholePeriodsCount = Math.max(1, wholePeriodsCount))
	// * timeUnitsCount);
	// break;
	// case WEEKS:
	// if (isBorderStartDateTimeGreater) {
	// wholePeriodsCount = Weeks.weeksBetween(currentPeriodBeginning,
	// borderStartDateTime).getWeeks()
	// / timeUnitsCount;
	// }
	// currentPeriodBeginning = currentPeriodBeginning
	// .plusWeeks((wholePeriodsCount = Math.max(1, wholePeriodsCount))
	// * timeUnitsCount);
	// break;
	// case MONTHS_ON_DATE:
	// if (isBorderStartDateTimeGreater) {
	// wholePeriodsCount = Months.monthsBetween(currentPeriodBeginning,
	// borderStartDateTime).getMonths()
	// / timeUnitsCount;
	// }
	// currentPeriodBeginning = currentPeriodBeginning
	// .plusMonths((wholePeriodsCount = Math.max(1, wholePeriodsCount))
	// * timeUnitsCount);
	// break;
	// case MONTHS_ON_NTH_WEEK_DAY:
	// if (isBorderStartDateTimeGreater) {
	// wholePeriodsCount = Months.monthsBetween(currentPeriodBeginning,
	// borderStartDateTime).getMonths()
	// / timeUnitsCount;
	// }
	// currentPeriodBeginning = currentPeriodBeginning
	// .plusMonths((wholePeriodsCount = Math.max(1, wholePeriodsCount))
	// * timeUnitsCount);
	// break;
	// case YEARS:
	// if (isBorderStartDateTimeGreater) {
	// wholePeriodsCount = Years.yearsBetween(currentPeriodBeginning,
	// borderStartDateTime).getYears()
	// / timeUnitsCount;
	// }
	// DateTime nextCurrentPeriodBeginning = currentPeriodBeginning
	// .plusYears((wholePeriodsCount = Math.max(1, wholePeriodsCount))
	// * timeUnitsCount);
	// int yearsBetween = Years.yearsBetween(currentPeriodBeginning,
	// nextCurrentPeriodBeginning).getYears();
	// for (int i = 1; i < yearsBetween; i++) {
	// int countIn_28_29_last = 0;
	// currentPeriodBeginning = currentPeriodBeginning.plusYears(1);
	// boolean isLeap = currentPeriodBeginning.property(
	// DateTimeFieldType.year()).isLeap();
	// if (isDayFebruary28Checked
	// && (isDayFebruary29Checked || isDayFebruaryLastChecked)
	// && isLeap) {
	// countIn_28_29_last = 2;
	// } else if (isDayFebruary28Checked
	// && (isDayFebruary29Checked || isDayFebruaryLastChecked)
	// && !isLeap && isDayFebruary28Checked
	// && !isDayFebruary29Checked && !isDayFebruaryLastChecked
	// || !isDayFebruary28Checked && isDayFebruary29Checked
	// && isDayFebruaryLastChecked || !isDayFebruary28Checked
	// && isDayFebruary29Checked && !isDayFebruaryLastChecked
	// && isLeap || !isDayFebruary28Checked
	// && !isDayFebruary29Checked && isDayFebruaryLastChecked) {
	// countIn_28_29_last = 1;
	// }
	// currentTaskOccurrencesCount += countIn_28_29_last
	// + countNotIn_28_29_last;
	// }
	// currentPeriodBeginning = nextCurrentPeriodBeginning;
	// break;
	// case ONE_TIME:
	// throw new IllegalArgumentException(
	// "getPreviousOccurrenceStartDateTimeOfRecurringTask() has been called on Task with recurrence interval ONE_TIME");
	// }
	// if (!recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
	// currentTaskOccurrencesCount += (wholePeriodsCount - 1)
	// * taskOccurrences.size();
	// }
	// }
	// }
	private List<CalendarViewTaskOccurrence> selectTaskOccurrencesOfRecurrentTask(
			Long borderStartDateTime, Long borderEndDateTime,
			boolean includeEventsMatchingControlDateTime,
			HashSet<CalendarViewTaskOccurrence> cacheOfCalendarViewTaskOccurrences,
			int firstDayOfWeek) {
		if (borderStartDateTime == null && borderEndDateTime == null) {
			throw new IllegalArgumentException(
					"Both borderStartDateTime1 and borderEndDateTime1 cannot be null");
		}
		int selectMode = 0;
		if (borderStartDateTime == null) {
			selectMode = -1;
		} else if (borderEndDateTime == null) {
			selectMode = 1;
		}
		List<CalendarViewTaskOccurrence> result = new ArrayList<CalendarViewTaskOccurrence>();
		Long previousOccurrenceStartDateTime = null;
		List<TaskOccurrence> taskOccurrences = getTaskOccurrenceList();
		RecurrenceInterval recurrenceInterval = RecurrenceInterval
				.fromInt(recurrenceIntervalValue);
		int count;
		if (recurrenceInterval.equals(RecurrenceInterval.MONTHS_ON_NTH_WEEK_DAY)) {
			count = taskOccurrences.size() - 1;
		} else {
			count = taskOccurrences.size();
		}
		if (count <= 0) {
			return result;
		}
		Long controlDateTime = null;
		if (selectMode == -1) {
			controlDateTime = borderEndDateTime;
		} else if (selectMode == 1) {
			controlDateTime = borderStartDateTime;
		}
		Calendar startDateTimeCalendar = Calendar.getInstance();
		startDateTimeCalendar.setTimeInMillis(startDateTime);
		int startDateTimeMillisOfDay = CalendarHelper
				.getMillisOfDay(startDateTimeCalendar);
		Calendar currentPeriodBeginning = (Calendar) startDateTimeCalendar.clone();
		if (recurrenceInterval.equals(RecurrenceInterval.WEEKS)) {
			CalendarHelper.toBeginningOfWeek(currentPeriodBeginning, firstDayOfWeek);
			currentPeriodBeginning.add(Calendar.MILLISECOND, startDateTimeMillisOfDay);
		} else if (recurrenceInterval.equals(RecurrenceInterval.MONTHS_ON_DATE)) {
			currentPeriodBeginning.set(Calendar.DAY_OF_MONTH, 1);
		} else if (recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
			currentPeriodBeginning.set(Calendar.DAY_OF_YEAR, 1);
		}
		List<Calendar> taskOccurrencesStartDateTimes = new ArrayList<Calendar>(count);
		int month;
		int year;
		int weekCode = taskOccurrences.get(taskOccurrences.size() - 1).getOrdinalNumber();
		biz.advancedcalendar.calendar2.Period occurrencePeriod = null;
		if (startDateTime != null && endDateTime != null) {
			Calendar endDateTimeCalendar = Calendar.getInstance();
			endDateTimeCalendar.setTimeInMillis(endDateTime);
			occurrencePeriod = new biz.advancedcalendar.calendar2.Period(
					startDateTimeCalendar, endDateTimeCalendar);
		}
		//
		if (!recurrenceInterval.equals(RecurrenceInterval.MONTHS_ON_NTH_WEEK_DAY)) {
			if (recurrenceInterval.equals(RecurrenceInterval.WEEKS)) {
				Collections.sort(taskOccurrences, new TaskOccurrenceComparatorWeek(
						firstDayOfWeek));
			} else {
				Collections.sort(taskOccurrences, new TaskOccurrenceComparator());
			}
		}
		int currentTaskOccurrencesCount = 0;
		boolean isDayFebruary28Checked = false;
		boolean isDayFebruary29Checked = false;
		boolean isDayFebruaryLastChecked = false;
		if (recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
			for (TaskOccurrence taskOccurrence : taskOccurrences) {
				if (taskOccurrence.getOrdinalNumber() == 59) {
					isDayFebruary28Checked = true;
				}
				if (taskOccurrence.getOrdinalNumber() == 60) {
					isDayFebruary29Checked = true;
				}
				if (taskOccurrence.getOrdinalNumber() == 61) {
					isDayFebruaryLastChecked = true;
				}
			}
		}
		int countNotIn_28_29_last = 0;
		if (recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
			for (TaskOccurrence taskOccurrence : taskOccurrences) {
				int dayCode = taskOccurrence.getOrdinalNumber();
				if (dayCode < 59 || dayCode > 61) {
					countNotIn_28_29_last++;
				}
			}
		}
		Iterator<CalendarViewTaskOccurrence> iterator = null;
		if (cacheOfCalendarViewTaskOccurrences != null) {
			iterator = cacheOfCalendarViewTaskOccurrences.iterator();
		}
		while (true) {
			taskOccurrencesStartDateTimes.clear();
			Calendar supposedTaskOccurrenceStartDateTime;
			switch (recurrenceInterval) {
			case MONTHS_ON_NTH_WEEK_DAY:
				// we get here zero-based month (zero-based month is used in function
				// getNthOfMonth())
				month = currentPeriodBeginning.get(Calendar.MONTH);
				year = currentPeriodBeginning.get(Calendar.YEAR);
				for (int i = 0; i < count; i++) {
					supposedTaskOccurrenceStartDateTime = getNthOfMonth(weekCode,
							taskOccurrences.get(i).getOrdinalNumber(), month, year);
					supposedTaskOccurrenceStartDateTime.add(Calendar.MILLISECOND,
							startDateTimeMillisOfDay);
					if (startDateTime <= supposedTaskOccurrenceStartDateTime
							.getTimeInMillis()) {
						taskOccurrencesStartDateTimes
								.add(supposedTaskOccurrenceStartDateTime);
					}
				}
				break;
			case MINUTES:
				for (TaskOccurrence taskOccurrence : taskOccurrences) {
					supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
							.clone();
					supposedTaskOccurrenceStartDateTime.add(Calendar.MINUTE,
							taskOccurrence.getOrdinalNumber() - 1);
					if (startDateTime <= supposedTaskOccurrenceStartDateTime
							.getTimeInMillis()) {
						taskOccurrencesStartDateTimes
								.add(supposedTaskOccurrenceStartDateTime);
					}
				}
				break;
			case HOURS:
				for (TaskOccurrence taskOccurrence : taskOccurrences) {
					supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
							.clone();
					supposedTaskOccurrenceStartDateTime.add(Calendar.HOUR_OF_DAY,
							taskOccurrence.getOrdinalNumber() - 1);
					if (startDateTime <= supposedTaskOccurrenceStartDateTime
							.getTimeInMillis()) {
						taskOccurrencesStartDateTimes
								.add(supposedTaskOccurrenceStartDateTime);
					}
				}
				break;
			case WEEKS:
				for (TaskOccurrence taskOccurrence : taskOccurrences) {
					Calendar currentPeriodBeginningClone = (Calendar) currentPeriodBeginning
							.clone();
					currentPeriodBeginningClone
							.add(Calendar.DAY_OF_YEAR,
									firstDayOfWeek <= taskOccurrence.getOrdinalNumber() ? taskOccurrence
											.getOrdinalNumber() - firstDayOfWeek
											: taskOccurrence.getOrdinalNumber()
													- firstDayOfWeek + 7);
					supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginningClone
							.clone();
					if (startDateTime <= supposedTaskOccurrenceStartDateTime
							.getTimeInMillis()) {
						taskOccurrencesStartDateTimes
								.add(supposedTaskOccurrenceStartDateTime);
					}
				}
				break;
			case DAYS:
			case MONTHS_ON_DATE:
				boolean isLastDayAlreadyWasTriedToAdd = false;
				for (TaskOccurrence taskOccurrence : taskOccurrences) {
					int day = taskOccurrence.getOrdinalNumber();
					boolean tryToAdd = true;
					switch (day) {
					case 28:
						int lastDay = currentPeriodBeginning
								.getActualMaximum(Calendar.DAY_OF_MONTH);
						if (lastDay == 28) {
							isLastDayAlreadyWasTriedToAdd = true;
						}
						break;
					case 29:
						if (!isLastDayAlreadyWasTriedToAdd) {
							int month1 = currentPeriodBeginning.get(Calendar.MONTH);
							if (month1 == Calendar.FEBRUARY) {
								boolean isLeap = CalendarHelper
										.isLeapYear(currentPeriodBeginning
												.get(Calendar.YEAR));
								if (!isLeap) {
									tryToAdd = false;
								}
							}
							lastDay = currentPeriodBeginning
									.getActualMaximum(Calendar.DAY_OF_MONTH);
							if (lastDay == 29) {
								isLastDayAlreadyWasTriedToAdd = true;
							}
						}
						break;
					case 30:
						if (!isLastDayAlreadyWasTriedToAdd) {
							int month1 = currentPeriodBeginning.get(Calendar.MONTH);
							if (month1 == Calendar.FEBRUARY) {
								tryToAdd = false;
							}
							lastDay = currentPeriodBeginning
									.getActualMaximum(Calendar.DAY_OF_MONTH);
							if (lastDay == 30) {
								isLastDayAlreadyWasTriedToAdd = true;
							}
							break;
						}
					case 31:
						if (!isLastDayAlreadyWasTriedToAdd) {
							int month1 = currentPeriodBeginning.get(Calendar.MONTH);
							if (month1 == Calendar.FEBRUARY || month1 == Calendar.APRIL
									|| month1 == Calendar.JUNE
									|| month1 == Calendar.SEPTEMBER
									|| month1 == Calendar.NOVEMBER) {
								tryToAdd = false;
							}
							lastDay = currentPeriodBeginning
									.getActualMaximum(Calendar.DAY_OF_MONTH);
							if (lastDay == 31) {
								isLastDayAlreadyWasTriedToAdd = true;
							}
							break;
						}
					case 32:
						if (!isLastDayAlreadyWasTriedToAdd) {
							// int month1 = currentPeriodBeginning.getMonthOfYear();
							if (isLastDayAlreadyWasTriedToAdd) {
								tryToAdd = false;
							} else {
								day = currentPeriodBeginning
										.getActualMaximum(Calendar.DAY_OF_MONTH);
							}
							break;
						} else {
							tryToAdd = false;
						}
					default:
						break;
					}
					if (tryToAdd) {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								day - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					}
				}
				break;
			case YEARS:
				boolean isLeap = CalendarHelper.isLeapYear(currentPeriodBeginning
						.get(Calendar.YEAR));
				if (isDayFebruary28Checked
						&& (isDayFebruary29Checked || isDayFebruaryLastChecked)) {
					if (isLeap) {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								59 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								60 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					} else {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								59 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					}
				} else if (isDayFebruary28Checked && !isDayFebruary29Checked
						&& !isDayFebruaryLastChecked) {
					supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
							.clone();
					supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR, 59 - 1);
					if (startDateTime <= supposedTaskOccurrenceStartDateTime
							.getTimeInMillis()) {
						taskOccurrencesStartDateTimes
								.add(supposedTaskOccurrenceStartDateTime);
					}
				} else if (!isDayFebruary28Checked && isDayFebruary29Checked
						&& isDayFebruaryLastChecked) {
					if (isLeap) {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								60 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					} else {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								59 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					}
				} else if (!isDayFebruary28Checked && isDayFebruary29Checked
						&& !isDayFebruaryLastChecked) {
					if (isLeap) {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								60 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					}
				} else if (!isDayFebruary28Checked && !isDayFebruary29Checked
						&& isDayFebruaryLastChecked) {
					if (isLeap) {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								60 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					} else {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								59 - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					}
				}
				for (TaskOccurrence taskOccurrence : taskOccurrences) {
					int dayCode = taskOccurrence.getOrdinalNumber();
					if (dayCode < 59) {
						supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
								.clone();
						supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
								dayCode - 1);
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					} else if (dayCode > 61) {
						if (isLeap) {
							supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
									.clone();
							supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
									dayCode - 2);
						} else {
							supposedTaskOccurrenceStartDateTime = (Calendar) currentPeriodBeginning
									.clone();
							supposedTaskOccurrenceStartDateTime.add(Calendar.DAY_OF_YEAR,
									dayCode - 3);
						}
						if (startDateTime <= supposedTaskOccurrenceStartDateTime
								.getTimeInMillis()) {
							taskOccurrencesStartDateTimes
									.add(supposedTaskOccurrenceStartDateTime);
						}
					}
				}
				break;
			case ONE_TIME:
				throw new IllegalArgumentException(
						"selectTaskOccurrencesOfRecurrentTask() has been called on Task with recurrence interval ONE_TIME");
			}
			Collections.sort(taskOccurrencesStartDateTimes);
			for (Calendar currentTaskOccurrenceStartDateTime : taskOccurrencesStartDateTimes) {
				currentTaskOccurrencesCount++;
				long currentTaskOccurrenceStartDateTimeMillis = currentTaskOccurrenceStartDateTime
						.getTimeInMillis();
				if (selectMode == -1) {
					if (repetitionEndDateTime != null
							&& repetitionEndDateTime <= currentTaskOccurrenceStartDateTimeMillis
							|| occurrencesMaxCount != null
							&& occurrencesMaxCount < currentTaskOccurrencesCount
							//
							|| includeEventsMatchingControlDateTime
							&& controlDateTime <= currentTaskOccurrenceStartDateTimeMillis
							|| !includeEventsMatchingControlDateTime
							&& controlDateTime < currentTaskOccurrenceStartDateTimeMillis) {
						if (previousOccurrenceStartDateTime != null
								&& (includeEventsMatchingControlDateTime
										&& previousOccurrenceStartDateTime <= controlDateTime || !includeEventsMatchingControlDateTime
										&& previousOccurrenceStartDateTime < controlDateTime)) {
							Long previousOccurrenceEndDateTime = null;
							if (occurrencePeriod != null) {
								Calendar calendar1 = Calendar.getInstance();
								calendar1
										.setTimeInMillis(previousOccurrenceStartDateTime);
								previousOccurrenceEndDateTime = CalendarHelper.plus(
										calendar1, occurrencePeriod).getTimeInMillis();
							}
							result.add(getCalendarViewTaskOccurrence(
									previousOccurrenceStartDateTime,
									previousOccurrenceEndDateTime, iterator));
						}
						return result;
					}
					previousOccurrenceStartDateTime = currentTaskOccurrenceStartDateTimeMillis;
				} else if (selectMode == 1) {
					if (repetitionEndDateTime != null
							&& repetitionEndDateTime <= currentTaskOccurrenceStartDateTimeMillis
							|| occurrencesMaxCount != null
							&& occurrencesMaxCount < currentTaskOccurrencesCount) {
						return result;
					}
					if (includeEventsMatchingControlDateTime
							&& controlDateTime <= currentTaskOccurrenceStartDateTimeMillis
							|| !includeEventsMatchingControlDateTime
							&& controlDateTime < currentTaskOccurrenceStartDateTimeMillis) {
						Long currentTaskOccurrenceEndDateTimeMillis = null;
						if (occurrencePeriod != null) {
							Calendar calendar1 = Calendar.getInstance();
							calendar1
									.setTimeInMillis(currentTaskOccurrenceStartDateTimeMillis);
							currentTaskOccurrenceEndDateTimeMillis = CalendarHelper.plus(
									calendar1, occurrencePeriod).getTimeInMillis();
						}
						result.add(getCalendarViewTaskOccurrence(
								currentTaskOccurrenceStartDateTimeMillis,
								currentTaskOccurrenceEndDateTimeMillis, iterator));
						return result;
					}
				} else {
					if (repetitionEndDateTime != null
							&& repetitionEndDateTime <= currentTaskOccurrenceStartDateTimeMillis
							|| occurrencesMaxCount != null
							&& occurrencesMaxCount < currentTaskOccurrencesCount
							|| borderEndDateTime <= currentTaskOccurrenceStartDateTimeMillis) {
						return result;
					}
					Long currentTaskOccurrenceEndDateTimeMillis = null;
					if (occurrencePeriod != null) {
						Calendar calendar1 = Calendar.getInstance();
						calendar1
								.setTimeInMillis(currentTaskOccurrenceStartDateTimeMillis);
						currentTaskOccurrenceEndDateTimeMillis = CalendarHelper.plus(
								calendar1, occurrencePeriod).getTimeInMillis();
					}
					result.add(getCalendarViewTaskOccurrence(
							currentTaskOccurrenceStartDateTimeMillis,
							currentTaskOccurrenceEndDateTimeMillis, iterator));
				}
			}
			//
			int wholePeriodsCount = 1;
			long controlBorderDateTime;
			if (selectMode != 0) {
				controlBorderDateTime = controlDateTime;
			} else {
				controlBorderDateTime = borderStartDateTime;
			}
			boolean isControlBorderDateTimeGreater = currentPeriodBeginning
					.getTimeInMillis() < controlBorderDateTime;
			Calendar calendar = null;
			if (isControlBorderDateTimeGreater) {
				Calendar controlBorderCalendar = Calendar.getInstance();
				controlBorderCalendar.setTimeInMillis(controlBorderDateTime);
				if (selectMode != 0) {
					calendar = controlBorderCalendar;
				} else {
					biz.advancedcalendar.calendar2.Period occurrencePeriodMinusOneMillis = occurrencePeriod
							.minusMillis(1);
					calendar = CalendarHelper.minus(controlBorderCalendar,
							occurrencePeriodMinusOneMillis);
				}
			}
			switch (recurrenceInterval) {
			case MINUTES:
				if (isControlBorderDateTimeGreater) {
					wholePeriodsCount = CalendarHelper.minutesBetween(
							currentPeriodBeginning, calendar) / timeUnitsCount;
				}
				currentPeriodBeginning.add(Calendar.MINUTE,
						(wholePeriodsCount = Math.max(1, wholePeriodsCount))
								* timeUnitsCount);
				break;
			case HOURS:
				if (isControlBorderDateTimeGreater) {
					wholePeriodsCount = CalendarHelper.hoursBetween(
							currentPeriodBeginning, calendar) / timeUnitsCount;
				}
				currentPeriodBeginning.add(Calendar.HOUR_OF_DAY,
						(wholePeriodsCount = Math.max(1, wholePeriodsCount))
								* timeUnitsCount);
				break;
			case DAYS:
				if (isControlBorderDateTimeGreater) {
					wholePeriodsCount = CalendarHelper.daysBetween(
							currentPeriodBeginning, calendar) / timeUnitsCount;
				}
				currentPeriodBeginning.add(Calendar.DAY_OF_YEAR,
						(wholePeriodsCount = Math.max(1, wholePeriodsCount))
								* timeUnitsCount);
				break;
			case WEEKS:
				if (isControlBorderDateTimeGreater) {
					wholePeriodsCount = CalendarHelper.weeksBetween(
							currentPeriodBeginning, calendar) / timeUnitsCount;
				}
				currentPeriodBeginning.add(Calendar.WEEK_OF_YEAR,
						(wholePeriodsCount = Math.max(1, wholePeriodsCount))
								* timeUnitsCount);
				break;
			case MONTHS_ON_DATE:
				if (isControlBorderDateTimeGreater) {
					wholePeriodsCount = CalendarHelper.monthsBetween(
							currentPeriodBeginning, calendar) / timeUnitsCount;
				}
				currentPeriodBeginning.add(Calendar.MONTH,
						(wholePeriodsCount = Math.max(1, wholePeriodsCount))
								* timeUnitsCount);
				break;
			case MONTHS_ON_NTH_WEEK_DAY:
				if (isControlBorderDateTimeGreater) {
					wholePeriodsCount = CalendarHelper.monthsBetween(
							currentPeriodBeginning, calendar) / timeUnitsCount;
				}
				currentPeriodBeginning.add(Calendar.MONTH,
						(wholePeriodsCount = Math.max(1, wholePeriodsCount))
								* timeUnitsCount);
				break;
			case YEARS:
				if (isControlBorderDateTimeGreater) {
					wholePeriodsCount = CalendarHelper.yearsBetween(
							currentPeriodBeginning, calendar) / timeUnitsCount;
				}
				Calendar nextCurrentPeriodBeginning = (Calendar) currentPeriodBeginning
						.clone();
				nextCurrentPeriodBeginning.add(Calendar.YEAR,
						(wholePeriodsCount = Math.max(1, wholePeriodsCount))
								* timeUnitsCount);
				int yearsBetween = CalendarHelper.yearsBetween(currentPeriodBeginning,
						nextCurrentPeriodBeginning);
				for (int i = 1; i < yearsBetween; i++) {
					int countIn_28_29_last = 0;
					currentPeriodBeginning.add(Calendar.YEAR, 1);
					boolean isLeap = CalendarHelper.isLeapYear(currentPeriodBeginning
							.get(Calendar.YEAR));
					if (isDayFebruary28Checked
							&& (isDayFebruary29Checked || isDayFebruaryLastChecked)
							&& isLeap) {
						countIn_28_29_last = 2;
					} else if (isDayFebruary28Checked
							&& (isDayFebruary29Checked || isDayFebruaryLastChecked)
							&& !isLeap && isDayFebruary28Checked
							&& !isDayFebruary29Checked && !isDayFebruaryLastChecked
							|| !isDayFebruary28Checked && isDayFebruary29Checked
							&& isDayFebruaryLastChecked || !isDayFebruary28Checked
							&& isDayFebruary29Checked && !isDayFebruaryLastChecked
							&& isLeap || !isDayFebruary28Checked
							&& !isDayFebruary29Checked && isDayFebruaryLastChecked) {
						countIn_28_29_last = 1;
					}
					currentTaskOccurrencesCount += countIn_28_29_last
							+ countNotIn_28_29_last;
				}
				currentPeriodBeginning = nextCurrentPeriodBeginning;
				break;
			case ONE_TIME:
				throw new IllegalArgumentException(
						"selectTaskOccurrencesOfRecurrentTask() has been called on Task with recurrence interval ONE_TIME");
			}
			if (!recurrenceInterval.equals(RecurrenceInterval.YEARS)) {
				currentTaskOccurrencesCount += (wholePeriodsCount - 1)
						* taskOccurrences.size();
			}
		}
	}

	public List<CalendarViewTaskOccurrence> selectTaskOccurrences(
			long borderStartDateTime, long borderEndDateTime, int firstDayOfWeek,
			HashSet<CalendarViewTaskOccurrence> cacheOfCalendarViewTaskOccurrences) {
		switch (RecurrenceInterval.fromInt(recurrenceIntervalValue)) {
		case ONE_TIME:
			// if (borderStartDateTime == null && borderEndDateTime == null) {
			// throw new IllegalArgumentException(
			// "Both borderStartDateTime1 and borderEndDateTime1 cannot be null");
			// }
			// int selectMode = 0;
			// if (borderStartDateTime == null) {
			// selectMode = -1;
			// } else if (borderEndDateTime == null) {
			// selectMode = 1;
			// }
			List<CalendarViewTaskOccurrence> result = new ArrayList<CalendarViewTaskOccurrence>();
			if (isTouchingInterval(startDateTime, endDateTime, borderStartDateTime,
					borderEndDateTime)) {
				Iterator<CalendarViewTaskOccurrence> iterator = null;
				if (cacheOfCalendarViewTaskOccurrences != null) {
					iterator = cacheOfCalendarViewTaskOccurrences.iterator();
				}
				result.add(getCalendarViewTaskOccurrence(startDateTime, endDateTime,
						iterator));
			}
			return result;
		case DAYS:
		case WEEKS:
		case HOURS:
		case MINUTES:
		case MONTHS_ON_DATE:
		case MONTHS_ON_NTH_WEEK_DAY:
		case YEARS:
		default:
			return selectTaskOccurrencesOfRecurrentTask(borderStartDateTime,
					borderEndDateTime, false, cacheOfCalendarViewTaskOccurrences,
					firstDayOfWeek);
		}
	}

	private CalendarViewTaskOccurrence getCalendarViewTaskOccurrence(
			Long taskOccurrenceStartDateTime, Long taskOccurrenceEndDateTime,
			Iterator<CalendarViewTaskOccurrence> iterator) {
		CalendarViewTaskOccurrence calendarViewTaskOccurrence;
		if (iterator != null && iterator.hasNext()) {
			calendarViewTaskOccurrence = iterator.next();
			iterator.remove();
			calendarViewTaskOccurrence.init(this, taskOccurrenceStartDateTime,
					taskOccurrenceEndDateTime);
		} else {
			calendarViewTaskOccurrence = new CalendarViewTaskOccurrence(this,
					taskOccurrenceStartDateTime, taskOccurrenceEndDateTime);
		}
		return calendarViewTaskOccurrence;
	}

	private boolean isTakingWholeInterval(long startDateTime, long endDateTime,
			long borderStartDateTime, long borderEndDateTime) {
		if (startDateTime <= borderStartDateTime && borderEndDateTime <= endDateTime) {
			return true;
		}
		return false;
	}

	private boolean isTakingWholeInterval(Long startDateTime, Long endDateTime,
			long borderStartDateTime, long borderEndDateTime) {
		if (startDateTime == null
				&& endDateTime == null
				//
				|| startDateTime != null
				&& endDateTime == null
				&& startDateTime <= borderStartDateTime
				//
				|| startDateTime == null
				&& endDateTime != null
				&& borderEndDateTime <= endDateTime
				//
				|| startDateTime != null
				&& endDateTime != null
				&& isTakingWholeInterval(startDateTime.longValue(),
						endDateTime.longValue(), borderStartDateTime, borderEndDateTime)) {
			return true;
		}
		return false;
	}

	private boolean isTakingNotWholeInterval(long startDateTime, long endDateTime,
			long borderStartDateTime, long borderEndDateTime) {
		if (startDateTime == endDateTime
				&& borderStartDateTime <= startDateTime
				&& startDateTime < borderEndDateTime
				//
				|| startDateTime != endDateTime
				//
				&& (startDateTime <= borderStartDateTime
						&& borderStartDateTime < endDateTime
						&& endDateTime < borderEndDateTime
						//
						|| borderStartDateTime <= startDateTime
						&& endDateTime < borderEndDateTime
						//
						|| borderStartDateTime < startDateTime
						&& endDateTime <= borderEndDateTime
				//
				|| borderStartDateTime < startDateTime
						&& startDateTime < borderEndDateTime
						&& borderEndDateTime <= endDateTime)) {
			return true;
		}
		return false;
	}

	private boolean isTakingNotWholeInterval(Long startDateTime, Long endDateTime,
			long borderStartDateTime, long borderEndDateTime) {
		if (startDateTime != null
				&& endDateTime == null
				&& borderStartDateTime < startDateTime
				&& startDateTime < borderEndDateTime
				//
				|| startDateTime == null && endDateTime != null
				&& borderStartDateTime < endDateTime
				&& endDateTime < borderEndDateTime
				//
				|| startDateTime != null
				&& endDateTime != null
				&& isTakingNotWholeInterval(startDateTime.longValue(),
						endDateTime.longValue(), borderStartDateTime, borderEndDateTime)) {
			return true;
		}
		return false;
	}

	private boolean isTouchingInterval(Long startDateTime, Long endDateTime,
			long borderStartDateTime, long borderEndDateTime) {
		return isTakingWholeInterval(startDateTime, endDateTime, borderStartDateTime,
				borderEndDateTime)
				|| isTakingNotWholeInterval(startDateTime, endDateTime,
						borderStartDateTime, borderEndDateTime);
	}

	private Calendar getNthOfMonth(int n, int day_of_week, int month, int year) {
		Calendar calendar = Calendar.getInstance();
		calendar.clear();
		calendar.set(year, month, 1, 0, 0, 0);
		calendar.set(Calendar.DAY_OF_WEEK, day_of_week);
		calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, n);
		return calendar;
	}

	public String getRingtone(int preferenceId) {
		return preferenceId == R.string.preference_key_alarm_ringtone ? alarmRingtone
				: notificationRingtone;
	}

	public String getRingtone2(Context context, int preferenceId) {
		switch (preferenceId) {
		case R.string.preference_key_alarm_ringtone:
			if (alarmRingtone != null) {
				return alarmRingtone;
			}
			break;
		case R.string.preference_key_notification_ringtone:
			if (notificationRingtone != null) {
				return notificationRingtone;
			}
			break;
		default:
			break;
		}
		return Helper
				.getStringPreferenceValue(
						context,
						preferenceId,
						RingtoneManager
								.getDefaultUri(
										preferenceId == R.string.preference_key_alarm_ringtone ? RingtoneManager.TYPE_ALARM
												: RingtoneManager.TYPE_NOTIFICATION)
								.toString());
	}

	public String getAlarmRingtone2(Context context) {
		if (alarmRingtone != null) {
			return alarmRingtone;
		} else {
			return Helper.getStringPreferenceValue(context, context.getResources()
					.getString(R.string.preference_key_alarm_ringtone), RingtoneManager
					.getDefaultUri(RingtoneManager.TYPE_ALARM).toString());
		}
	}

	public String getRingtoneTitle(Context context, int preferenceId) {
		String ringtoneString = getRingtone2(context, preferenceId);
		return Helper.getRingtoneTitle(context, ringtoneString);
	}

	public String getAlarmRingtoneTitle(Context context) {
		String ringtoneString = getAlarmRingtone2(context);
		return Helper.getRingtoneTitle(context, ringtoneString);
	}

	public String getNotificationRingtone2(Context context) {
		if (notificationRingtone != null) {
			return notificationRingtone;
		} else {
			return Helper.getStringPreferenceValue(context, context.getResources()
					.getString(R.string.preference_key_notification_ringtone),
					RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)
							.toString());
		}
	}

	public String getNotificationRingtoneTitle(Context context) {
		String ringtoneString = getNotificationRingtone2(context);
		return Helper.getRingtoneTitle(context, ringtoneString);
	}

	public long getRingtoneFadeInTime2(Context context, int preferenceKey,
			long defaultValue, Long minValue, Long maxValue) {
		if (ringtoneFadeInTime != null) {
			return ringtoneFadeInTime;
		}
		return Helper.getLongFromStringPreferenceValue(context, preferenceKey,
				defaultValue, minValue, maxValue);
	}

	public int getPlayingTime2(Context context, int preferenceKey, int defaultValue,
			Integer minValue, Integer maxValue) {
		if (playingTime != null) {
			return playingTime;
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey, null,
				defaultValue, minValue, maxValue);
	}

	public int getAutomaticSnoozeDuration2(Context context, int preferenceKey,
			int defaultValue, Integer minValue, Integer maxValue) {
		if (automaticSnoozeDuration != null) {
			return automaticSnoozeDuration;
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey, null,
				defaultValue, minValue, maxValue);
	}

	public int getAutomaticSnoozesMaxCount2(Context context, int preferenceKey,
			int defaultValue, Integer minValue, Integer maxValue) {
		if (automaticSnoozesMaxCount != null) {
			return automaticSnoozesMaxCount;
		}
		return Helper.getIntegerFromStringPreferenceValue(context, preferenceKey, null,
				defaultValue, minValue, maxValue);
	}

	public boolean getVibrate2(Context context, String preferenceKey, boolean defaultValue) {
		if (vibrate != null) {
			return vibrate;
		}
		return Helper.getBooleanPreferenceValue(context, preferenceKey, defaultValue);
	}

	public Integer getColor2(Context context) {
		if (color != null) {
			return color;
		} else {
			Resources resources = context.getResources();
			switch (PRIORITY.fromInt(priority)) {
			case HIGH:
				return resources.getColor(R.color.task_high_priority_default_color);
			case LOW:
				return resources.getColor(R.color.task_low_priority_default_color);
			case MEDIUM:
			default:
				int color = Helper.getIntegerPreferenceValue(context,
						R.string.preference_key_task_unset_color,
						resources.getColor(R.color.task_unset_color_default_value),
						null, null);
				return color;
			}
		}
	}

	protected Task(Parcel in) {
		id = in.readByte() == 0x00 ? null : in.readLong();
		calendarId = in.readByte() == 0x00 ? null : in.readLong();
		parentId = in.readByte() == 0x00 ? null : in.readLong();
		localCreateDateTime = in.readLong();
		localChangeDateTime = in.readLong();
		serverId = in.readByte() == 0x00 ? null : in.readLong();
		created = in.readByte() == 0x00 ? null : in.readLong();
		lastMod = in.readByte() == 0x00 ? null : in.readLong();
		syncStatusValue = in.readByte();
		name = in.readString();
		priority = (Short) in.readValue(short.class.getClassLoader());
		color = in.readByte() == 0x00 ? null : in.readInt();
		startDateTime = in.readByte() == 0x00 ? null : in.readLong();
		endDateTime = in.readByte() == 0x00 ? null : in.readLong();
		requiredLength = in.readByte() == 0x00 ? null : in.readInt();
		actualLength = in.readByte() == 0x00 ? null : in.readInt();
		isCompleted = in.readByte() != 0x00;
		percentOfCompletion = (Short) in.readValue(short.class.getClassLoader());
		completedTime = in.readByte() == 0x00 ? null : in.readLong();
		deleted = in.readByte() != 0x00;
		sortOrder = in.readInt();
		description = in.readString();
		location = in.readString();
		recurrenceIntervalValue = (Short) in.readValue(short.class.getClassLoader());
		timeUnitsCount = in.readByte() == 0x00 ? null : in.readInt();
		occurrencesMaxCount = in.readByte() == 0x00 ? null : in.readInt();
		repetitionEndDateTime = in.readByte() == 0x00 ? null : in.readLong();
		alarmRingtone = in.readString();
		notificationRingtone = in.readString();
		ringtoneFadeInTime = in.readByte() == 0x00 ? null : in.readLong();
		playingTime = in.readByte() == 0x00 ? null : in.readInt();
		automaticSnoozeDuration = in.readByte() == 0x00 ? null : in.readInt();
		automaticSnoozesMaxCount = in.readByte() == 0x00 ? null : in.readInt();
		byte vibrateVal = in.readByte();
		vibrate = vibrateVal == 0x02 ? null : vibrateVal != 0x00;
		vibratePattern = in.readString();
		byte ledVal = in.readByte();
		led = ledVal == 0x02 ? null : ledVal != 0x00;
		ledPattern = in.readString();
		ledColor = in.readByte() == 0x00 ? null : in.readInt();
	}

	@Override
	public int describeContents() {
		return 0;
	}

	@Override
	public void writeToParcel(Parcel dest, int flags) {
		if (id == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(id);
		}
		if (calendarId == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(calendarId);
		}
		if (parentId == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(parentId);
		}
		dest.writeLong(localCreateDateTime);
		dest.writeLong(localChangeDateTime);
		if (serverId == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(serverId);
		}
		if (created == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(created);
		}
		if (lastMod == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(lastMod);
		}
		dest.writeByte(syncStatusValue);
		dest.writeString(name);
		dest.writeValue(priority);
		if (color == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(color);
		}
		if (startDateTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(startDateTime);
		}
		if (endDateTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(endDateTime);
		}
		if (requiredLength == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(requiredLength);
		}
		if (actualLength == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(actualLength);
		}
		dest.writeByte((byte) (isCompleted ? 0x01 : 0x00));
		dest.writeValue(percentOfCompletion);
		if (completedTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(completedTime);
		}
		dest.writeByte((byte) (deleted ? 0x01 : 0x00));
		dest.writeInt(sortOrder);
		dest.writeString(description);
		dest.writeString(location);
		dest.writeValue(recurrenceIntervalValue);
		if (timeUnitsCount == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(timeUnitsCount);
		}
		if (occurrencesMaxCount == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(occurrencesMaxCount);
		}
		if (repetitionEndDateTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(repetitionEndDateTime);
		}
		dest.writeString(alarmRingtone);
		dest.writeString(notificationRingtone);
		if (ringtoneFadeInTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeLong(ringtoneFadeInTime);
		}
		if (playingTime == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(playingTime);
		}
		if (automaticSnoozeDuration == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(automaticSnoozeDuration);
		}
		if (automaticSnoozesMaxCount == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(automaticSnoozesMaxCount);
		}
		if (vibrate == null) {
			dest.writeByte((byte) 0x02);
		} else {
			dest.writeByte((byte) (vibrate ? 0x01 : 0x00));
		}
		dest.writeString(vibratePattern);
		if (led == null) {
			dest.writeByte((byte) 0x02);
		} else {
			dest.writeByte((byte) (led ? 0x01 : 0x00));
		}
		dest.writeString(ledPattern);
		if (ledColor == null) {
			dest.writeByte((byte) 0x00);
		} else {
			dest.writeByte((byte) 0x01);
			dest.writeInt(ledColor);
		}
	}

	public static final Parcelable.Creator<Task> CREATOR = new Parcelable.Creator<Task>() {
		@Override
		public Task createFromParcel(Parcel in) {
			return new Task(in);
		}

		@Override
		public Task[] newArray(int size) {
			return new Task[size];
		}
	};
	// KEEP METHODS END
}
